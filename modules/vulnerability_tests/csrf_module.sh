#!/bin/bash

# CSRF Testing Module
# Tests for Cross-Site Request Forgery vulnerabilities

source "$(dirname "${BASH_SOURCE[0]}")/../../core/logger.sh"
source "$(dirname "${BASH_SOURCE[0]}")/../../core/database.sh"

# Main CSRF testing function
test_csrf() {
    local url=$1
    local project_id=$2

    log_info "Testing CSRF vulnerabilities on $url"

    # Test for CSRF token presence and validation
    test_csrf_token_validation "$url" "$project_id"

    # Test for SameSite cookie attribute
    test_samesite_cookies "$url" "$project_id"

    # Test for referer/origin validation
    test_referer_validation "$url" "$project_id"
}

# Test CSRF token presence and validation
test_csrf_token_validation() {
    local url=$1
    local project_id=$2

    log_info "[CSRF] Testing CSRF token validation"

    # Fetch the page
    local cookie_file="/tmp/csrf_cookies_$$.txt"
    local response=$(curl -s -L -c "$cookie_file" "$url")

    # Common CSRF token names
    local csrf_patterns=(
        "csrf_token"
        "csrf"
        "_token"
        "authenticity_token"
        "anti-forgery-token"
        "__RequestVerificationToken"
        "csrfmiddlewaretoken"
        "_csrf"
        "XSRF-TOKEN"
    )

    # Check for CSRF tokens in the response
    local csrf_token_found=false
    local csrf_token_name=""
    local csrf_token_value=""

    for pattern in "${csrf_patterns[@]}"; do
        # Check in hidden input fields
        if echo "$response" | grep -qiE "<input[^>]*name=[\"']?${pattern}[\"']?"; then
            csrf_token_found=true
            csrf_token_name="$pattern"
            csrf_token_value=$(echo "$response" | grep -oP "<input[^>]*name=[\"']?${pattern}[\"']?[^>]*value=[\"']?\K[^\"'\s>]+")
            log_debug "[CSRF] Token found in hidden input: $csrf_token_name"
            break
        fi

        # Check in meta tags
        if echo "$response" | grep -qiE "<meta[^>]*name=[\"']?${pattern}[\"']?"; then
            csrf_token_found=true
            csrf_token_name="$pattern"
            csrf_token_value=$(echo "$response" | grep -oP "<meta[^>]*name=[\"']?${pattern}[\"']?[^>]*content=[\"']?\K[^\"'\s>]+")
            log_debug "[CSRF] Token found in meta tag: $csrf_token_name"
            break
        fi

        # Check in cookies
        if grep -qi "$pattern" "$cookie_file"; then
            csrf_token_found=true
            csrf_token_name="$pattern"
            log_debug "[CSRF] Token found in cookie: $csrf_token_name"
            break
        fi
    done

    if [ "$csrf_token_found" = false ]; then
        # No CSRF token found - vulnerability
        log_critical "[CSRF] No CSRF token found!"

        # Check if there are state-changing forms
        if echo "$response" | grep -qiE "<form[^>]*(method=[\"']?post|action=)"; then
            generate_csrf_poc "$url" "$project_id" "$response"

            db_add_finding "$project_id" "high" "csrf_missing_token" \
                "CSRF Protection Missing" \
                "URL: $url\n\nNo CSRF protection tokens found on this page, which contains POST forms.\n\nAn attacker can craft a malicious page that submits requests on behalf of authenticated users without their consent." \
                "" "8.1" \
                "1. Implement CSRF tokens (Synchronizer Token Pattern)\n2. Use the Double Submit Cookie pattern\n3. Implement SameSite cookie attribute\n4. Verify Origin and Referer headers\n5. Require re-authentication for sensitive actions\n6. Use framework built-in CSRF protection"

            rm -f "$cookie_file"
            return 0
        fi
    else
        # CSRF token found - test if it's validated
        log_debug "[CSRF] CSRF token found: $csrf_token_name, testing validation..."
        test_csrf_token_enforcement "$url" "$project_id" "$csrf_token_name" "$csrf_token_value" "$response"
    fi

    rm -f "$cookie_file"
}

# Test if CSRF token is actually enforced
test_csrf_token_enforcement() {
    local url=$1
    local project_id=$2
    local token_name=$3
    local token_value=$4
    local original_response=$5

    log_debug "[CSRF] Testing CSRF token enforcement"

    # Extract form action and method
    local form_action=$(echo "$original_response" | grep -oP '<form[^>]*action=["'"'"']?\K[^"'"'"'\s>]+' | head -1)
    local form_method=$(echo "$original_response" | grep -oP '<form[^>]*method=["'"'"']?\K[^"'"'"'\s>]+' | head -1 | tr '[:upper:]' '[:lower:]')

    # Default to POST if not specified
    [ -z "$form_method" ] && form_method="post"

    # Build absolute URL
    local submit_url
    if [[ "$form_action" == http* ]]; then
        submit_url="$form_action"
    elif [[ "$form_action" == /* ]]; then
        local base_domain=$(echo "$url" | grep -oP '^https?://[^/]+')
        submit_url="${base_domain}${form_action}"
    else
        submit_url="${url%/*}/${form_action}"
    fi

    # Extract all form fields
    local input_fields=$(echo "$original_response" | grep -oP '<input[^>]*name=["'"'"']?\K[^"'"'"'\s>]+')
    local post_data=""

    while read -r field; do
        if [ "$field" != "$token_name" ]; then
            post_data="${post_data}${field}=test&"
        fi
    done <<< "$input_fields"
    post_data="${post_data%&}"

    # Test 1: Submit without CSRF token
    log_debug "[CSRF] Test 1: Submitting without CSRF token"
    local response_no_token=$(curl -s -w "\n---HTTP_CODE:%{http_code}---" \
                              -X "$form_method" "$submit_url" \
                              -d "$post_data" \
                              -H "Content-Type: application/x-www-form-urlencoded" \
                              2>/dev/null)

    local http_code_no_token=$(echo "$response_no_token" | grep -oP '---HTTP_CODE:\K\d+')
    local body_no_token=$(echo "$response_no_token" | sed -n '1,/---HTTP_CODE:/p' | head -n -1)

    # Check if request was rejected
    if [ "$http_code_no_token" = "200" ] && ! echo "$body_no_token" | grep -qiE "invalid.*token|csrf|forbidden|unauthorized"; then
        log_critical "[CSRF] Request succeeded without CSRF token!"

        db_add_finding "$project_id" "high" "csrf_token_not_enforced" \
            "CSRF Token Not Enforced" \
            "URL: $submit_url\nToken Name: $token_name\n\nAlthough a CSRF token is present in the form, the application accepts requests without it.\n\nHTTP Code without token: $http_code_no_token\n\nThis allows CSRF attacks despite the presence of a token field." \
            "" "8.0" \
            "1. Enforce CSRF token validation on the server-side\n2. Reject requests with missing or invalid tokens\n3. Ensure tokens are tied to user sessions\n4. Implement proper error handling for invalid tokens"

        generate_csrf_poc "$url" "$project_id" "$original_response"
        return 0
    fi

    # Test 2: Submit with invalid CSRF token
    log_debug "[CSRF] Test 2: Submitting with invalid CSRF token"
    local invalid_token="invalid_csrf_token_12345"
    local response_bad_token=$(curl -s -w "\n---HTTP_CODE:%{http_code}---" \
                               -X "$form_method" "$submit_url" \
                               -d "${post_data}&${token_name}=${invalid_token}" \
                               -H "Content-Type: application/x-www-form-urlencoded" \
                               2>/dev/null)

    local http_code_bad_token=$(echo "$response_bad_token" | grep -oP '---HTTP_CODE:\K\d+')
    local body_bad_token=$(echo "$response_bad_token" | sed -n '1,/---HTTP_CODE:/p' | head -n -1)

    if [ "$http_code_bad_token" = "200" ] && ! echo "$body_bad_token" | grep -qiE "invalid.*token|csrf|forbidden|unauthorized"; then
        log_critical "[CSRF] Request succeeded with invalid CSRF token!"

        db_add_finding "$project_id" "high" "csrf_token_not_validated" \
            "CSRF Token Not Properly Validated" \
            "URL: $submit_url\nToken Name: $token_name\n\nThe application accepts requests with invalid CSRF tokens.\n\nHTTP Code with invalid token: $http_code_bad_token\n\nThis defeats the purpose of CSRF protection." \
            "" "7.8" \
            "1. Validate CSRF token value on the server-side\n2. Compare submitted token with session-stored token\n3. Use cryptographically strong random tokens\n4. Regenerate tokens after sensitive actions"

        generate_csrf_poc "$url" "$project_id" "$original_response"
        return 0
    fi

    # Test 3: Check if token is reusable
    log_debug "[CSRF] Test 3: Testing token reusability"
    sleep 2

    local response_reused=$(curl -s -w "\n---HTTP_CODE:%{http_code}---" \
                            -X "$form_method" "$submit_url" \
                            -d "${post_data}&${token_name}=${token_value}" \
                            -H "Content-Type: application/x-www-form-urlencoded" \
                            2>/dev/null)

    local http_code_reused=$(echo "$response_reused" | grep -oP '---HTTP_CODE:\K\d+')

    if [ "$http_code_reused" = "200" ]; then
        log_warn "[CSRF] CSRF token is reusable (not single-use)"

        db_add_finding "$project_id" "medium" "csrf_token_reusable" \
            "CSRF Token is Reusable" \
            "URL: $submit_url\nToken Name: $token_name\n\nThe CSRF token can be reused multiple times.\n\nWhile this doesn't directly enable CSRF attacks, it weakens the protection by allowing token leakage to be exploited for longer periods." \
            "" "5.3" \
            "1. Implement single-use (nonce) CSRF tokens\n2. Invalidate tokens after use\n3. Set short expiration times for tokens\n4. Regenerate tokens for each request"

        return 1
    fi

    log_success "[CSRF] CSRF token validation appears to be properly implemented"
    return 1
}

# Test SameSite cookie attribute
test_samesite_cookies() {
    local url=$1
    local project_id=$2

    log_info "[CSRF] Testing SameSite cookie attribute"

    # Fetch cookies with headers
    local headers=$(curl -s -I -L "$url")

    # Extract Set-Cookie headers
    local cookies=$(echo "$headers" | grep -i "Set-Cookie")

    if [ -z "$cookies" ]; then
        log_debug "[CSRF] No cookies set by the application"
        return 1
    fi

    # Check for session/auth cookies without SameSite
    local vulnerable_cookies=""

    while read -r cookie_line; do
        # Extract cookie name
        local cookie_name=$(echo "$cookie_line" | grep -oP 'Set-Cookie: \K[^=]+')

        # Check if it's likely a session cookie
        if echo "$cookie_name" | grep -qiE "session|sess|auth|token|user|login"; then
            # Check if SameSite attribute is present
            if ! echo "$cookie_line" | grep -qiE "SameSite=(Strict|Lax)"; then
                log_warn "[CSRF] Session cookie without SameSite: $cookie_name"
                vulnerable_cookies="${vulnerable_cookies}\n- $cookie_name"
            fi
        fi
    done <<< "$cookies"

    if [ -n "$vulnerable_cookies" ]; then
        db_add_finding "$project_id" "medium" "csrf_no_samesite" \
            "Missing SameSite Cookie Attribute" \
            "URL: $url\n\nThe following session/authentication cookies do not have the SameSite attribute set:\n${vulnerable_cookies}\n\nWithout SameSite=Strict or SameSite=Lax, cookies are sent with cross-site requests, enabling CSRF attacks." \
            "" "6.5" \
            "1. Set SameSite=Strict for sensitive cookies (may break legitimate cross-site flows)\n2. Set SameSite=Lax as a balanced approach (recommended for most applications)\n3. Combine with CSRF tokens for defense in depth\n4. Example: Set-Cookie: sessionid=abc123; SameSite=Strict; Secure; HttpOnly"

        return 0
    fi

    return 1
}

# Test Referer/Origin header validation
test_referer_validation() {
    local url=$1
    local project_id=$2

    log_info "[CSRF] Testing Referer/Origin header validation"

    # Extract forms
    local response=$(curl -s -L "$url")

    if ! echo "$response" | grep -qiE "<form[^>]*(method=[\"']?post|action=)"; then
        log_debug "[CSRF] No POST forms found"
        return 1
    fi

    # Extract form action
    local form_action=$(echo "$response" | grep -oP '<form[^>]*action=["'"'"']?\K[^"'"'"'\s>]+' | head -1)

    # Build submit URL
    local submit_url
    if [[ "$form_action" == http* ]]; then
        submit_url="$form_action"
    elif [[ "$form_action" == /* ]]; then
        local base_domain=$(echo "$url" | grep -oP '^https?://[^/]+')
        submit_url="${base_domain}${form_action}"
    else
        submit_url="${url%/*}/${form_action}"
    fi

    # Test with evil Referer
    log_debug "[CSRF] Testing with malicious Referer header"

    local response_evil_referer=$(curl -s -w "\n---HTTP_CODE:%{http_code}---" \
                                  -X POST "$submit_url" \
                                  -H "Referer: https://evil-attacker.com/csrf-attack" \
                                  -H "Origin: https://evil-attacker.com" \
                                  -d "test=data" \
                                  2>/dev/null)

    local http_code=$(echo "$response_evil_referer" | grep -oP '---HTTP_CODE:\K\d+')

    if [ "$http_code" = "200" ]; then
        log_warn "[CSRF] Application accepts requests with malicious Referer/Origin headers"

        db_add_finding "$project_id" "low" "csrf_no_referer_check" \
            "Missing Referer/Origin Validation" \
            "URL: $submit_url\n\nThe application does not validate Referer or Origin headers for cross-site requests.\n\nWhile not a complete CSRF protection, this check provides defense in depth." \
            "" "4.3" \
            "1. Validate Referer header when present (optional defense layer)\n2. Validate Origin header for CORS requests\n3. Do NOT rely solely on Referer/Origin (can be stripped by proxies)\n4. Use CSRF tokens as primary protection\n5. Combine multiple defenses for depth"

        return 0
    fi

    return 1
}

# Generate CSRF proof-of-concept
generate_csrf_poc() {
    local url=$1
    local project_id=$2
    local response=$3

    log_info "[CSRF] Generating CSRF Proof-of-Concept"

    local poc_dir="data/projects/${project_id}/evidence/csrf"
    mkdir -p "$poc_dir"

    local timestamp=$(date +%Y%m%d_%H%M%S)
    local poc_file="${poc_dir}/csrf_poc_${timestamp}.html"

    # Extract form details
    local form_action=$(echo "$response" | grep -oP '<form[^>]*action=["'"'"']?\K[^"'"'"'\s>]+' | head -1)
    local form_method=$(echo "$response" | grep -oP '<form[^>]*method=["'"'"']?\K[^"'"'"'\s>]+' | head -1 | tr '[:upper:]' '[:lower:]')

    # Build absolute URL
    local target_url
    if [[ "$form_action" == http* ]]; then
        target_url="$form_action"
    elif [[ "$form_action" == /* ]]; then
        local base_domain=$(echo "$url" | grep -oP '^https?://[^/]+')
        target_url="${base_domain}${form_action}"
    else
        target_url="${url%/*}/${form_action}"
    fi

    [ -z "$form_method" ] && form_method="post"

    # Extract input fields
    local input_fields=""
    local field_names=$(echo "$response" | grep -oP '<input[^>]*name=["'"'"']?\K[^"'"'"'\s>]+')

    while read -r field; do
        # Skip CSRF token fields
        if ! echo "$field" | grep -qiE "csrf|token"; then
            input_fields="${input_fields}    <input type=\"hidden\" name=\"${field}\" value=\"attacker_value\">\n"
        fi
    done <<< "$field_names"

    # Generate HTML PoC
    cat > "$poc_file" <<EOF
<!DOCTYPE html>
<html>
<head>
    <title>CSRF Proof of Concept</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .warning { background: #ffebee; border-left: 4px solid #f44336; padding: 16px; margin: 20px 0; }
        .info { background: #e3f2fd; border-left: 4px solid #2196f3; padding: 16px; margin: 20px 0; }
        code { background: #f5f5f5; padding: 2px 6px; border-radius: 3px; }
    </style>
</head>
<body>
    <h1>CSRF Vulnerability - Proof of Concept</h1>

    <div class="warning">
        <strong>⚠️ Warning:</strong> This is a proof-of-concept for a CSRF vulnerability.
        Do not use this for malicious purposes.
    </div>

    <div class="info">
        <strong>Target URL:</strong> <code>$target_url</code><br>
        <strong>Method:</strong> <code>$(echo $form_method | tr '[:lower:]' '[:upper:]')</code><br>
        <strong>Vulnerability:</strong> Missing or improperly validated CSRF protection
    </div>

    <h2>Attack Scenario</h2>
    <p>
        An attacker can host this page and trick an authenticated user into visiting it.
        The form will automatically submit, performing actions on behalf of the victim
        without their knowledge or consent.
    </p>

    <h2>Exploit Form</h2>
    <form action="$target_url" method="$form_method" id="csrf_form">
$(echo -e "$input_fields")
        <input type="submit" value="Click here to trigger CSRF (manual)">
    </form>

    <h2>Auto-submit Test</h2>
    <p>The form will auto-submit in <span id="countdown">3</span> seconds...</p>

    <script>
        // Countdown and auto-submit
        let count = 3;
        const countdownEl = document.getElementById('countdown');

        const timer = setInterval(() => {
            count--;
            countdownEl.textContent = count;

            if (count === 0) {
                clearInterval(timer);
                // Uncomment the next line to enable auto-submit
                // document.getElementById('csrf_form').submit();
                countdownEl.textContent = 'Auto-submit disabled for safety';
            }
        }, 1000);
    </script>

    <div class="info" style="margin-top: 40px;">
        <h3>Remediation</h3>
        <ol>
            <li>Implement CSRF tokens using the Synchronizer Token Pattern</li>
            <li>Use the Double Submit Cookie pattern as an alternative</li>
            <li>Set <code>SameSite=Strict</code> or <code>SameSite=Lax</code> on session cookies</li>
            <li>Validate Origin and Referer headers</li>
            <li>Require re-authentication for sensitive actions</li>
        </ol>
    </div>

    <p><em>Generated by LeKnight Security Scanner - $(date)</em></p>
</body>
</html>
EOF

    log_success "[CSRF] PoC generated: $poc_file"

    # Add to finding description
    echo "CSRF Proof-of-Concept available at: $poc_file"
}

# Export functions
export -f test_csrf
export -f test_csrf_token_validation
export -f test_samesite_cookies
export -f test_referer_validation
